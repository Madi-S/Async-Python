# Coroutines

Короутина - компонент компьютерной программы, применяемый для кооперативной многозадачности. На первый взгляд, между тредом и короутиной совсем нет отличий. Обе сущности выполняются внутри одного процесса, а так же передается упрвление одной подпрограммы другой. Но в случае с тредами ОС контролирует переключение подпрограмм, а в реализации короутин эти переключения контролирует сам Python. Короутина - это также функция с ключевыми словами `async def` в определении, которую можно вызвать с ключевым словом `await`. Простой вызов подоббной функции без ключевого слова `await` вернет нам эту короутину, объект типа `coroutine`.

Смотри `1_http.py`

## Кооперативная многозадачность

Один из видов многозадачности, в котором ОС не управляет переключением контекста выполнения. Вместо этого внутри одного процесса происходят периодические прерывания, или логическаяя передача управления другим подпрограммам. Кооперативная многозадачность позволяет исполнять намного больше подпрограмм, чем треды. На число запущенных тредов в системе есть ограничение, и их инициализация требует больше ресурсов.

## Event Loop

Это сущность, управляющая задачами в асинхронной программе. Она следит за асинхронными задачами и принимает решение, какой задаче передать управление в определенны момент.

## Жизненный цикл короутины

![lifecycle](/static/coroutine_lifecycle.png)

Сразу после вызова `await` перед короутиной создается задача и помещается в `event loop`. Она будет находиться в очереди до тех пор, пока не придет результат. При завершении IO-операции операционная система вызовет `callback` и проставит результат в `task`. Когда `event loop` дойдет до этой задачи, он поймет, что задача завершена, и передаст управление короутине. То есть программа продолжит свое выполнение с первоначального места вызова `await`.

## IO Bound операции в короутинах

Эффективность данных операций в короутине резко возрастает, так как программа не тратила время на ожидание, а передавала управление другим короутинам. Все это отработало в одном потоке и одном процессе. Мы не тратили вычислительные мощности CPU на переключение и выделения ресурсов подпрограммам.

Смотри `2_io_bound.py`

## CPU Bound операции в короутинах

Синхронные операции в короутинах исполнять бесполезно, потому что выполнение короутин станет последовательным. Никакого выигрыша во времени мы не получим. Такую же картину мы получим при вычеслениях в разных тредах, так как обе сущности ограничены одним процессом, и, следовательно одним ядром, его обрабатывающим. В случае же многопроцессной обработки наш выигрыш во времени был бы в N раз больше, где N - число ядер, задействованных в обработке процессов.

Смотри `3_cpu_bound.py`

## Синхронный код в асинхронных функциях

Еще раз отметим, что асинхронный код дает свое преимущество только при использовании его с неблокирующими операциями ввода/вывода (IO Bound). Например, вызов синхронный функции `time.sleep()` превратит нашу программу в синхронную.

Смотри `4_sync_in_async.py`, где функция `time.sleep()` - блокирующая в отличие от `asyncio.sleep()`. Именно поэтому то же число короутин отрабатывает во столько раз больше, сколько короутин было запущено.

## Выводы:

1. Процессы имеют свою изолированную область памяти и исполняются параллельно на разных ядрах вычислительной системы.

2. Треды работают внутри процесса. Обрабатываются одним ядром из-за GIL. Переключение тредов осуществляется средствами ОС.

3. Короутины - подпрограммы, работающие внутри одного процесса и одного треда. Их управление осуществляется с помощью event loop.

4. CPU-операции лучше выполнять с использованием multiprocessing.

5. IO-bound операции лучше реализовывать методами кооперативной многозадачности, т.е.е внутри короутин.

6. Максимум производительности с IO-операциями можно получить, инициализировав число процессов, равное числу ядер на компьюетере. Внутри процессов следует использовать кооперативную многозадачность.
