# Threading & Multiprocessing

## Parallel, параллельные вычисления или параллельность

Одновременно обрабатывающиеся взаимосвязанные подпрограммы. Например, нужно решить одну и ту же задачу с различными вариантами входных параметров и получить значения. Мы можем спроектировать нашу программу так, чтобы она не решала задачу за задачей, а просчитывала несколько задач одновременно.

## Многопоточность

Это способность центрального процесса CPU - или одного ядра в многоядерном процессоре - одновременно выполнять несколько процессов или потоков, соответсвующим образом поддерживаемых операционной системой.

## Concurrency или конкурентность

Иногда еще называют "Одновременность". Но в действительности при конкурентности все операции выполняются вместе, но не одновременно Именно этот подход реализован в библиотеке asyncio.

## Возможные реализации этих парадигм программирования:

1. Треды

2. Процессы

3. Короутины

## Обзор

![example1](/static/parallel_concurrent.png)
![example2](/static/parallel_concurrent_reallife.png)

# Процессы и Треды

## Процессы (process)

Это некая сущность операционной системы, которая исполняет определенные инструкции.

Смотри `1_multiprocessing.py`

### Порождение процессов

Библиотека multiprocessing поддерживает 3 способа порождения процессов:

1. Spawn - запуск нового процесса интерпретатора Python. Будут унаследованы только те ресурсы, которые необходимы для запуска процесса.

2. Fork - системный вызов fork. Полное копирование дочернего процесса.

3. Forkserver - инициализвация однопоточного процесса сервера. При необходимости порождения дополнительных процессов происходит запрос к серверу, и он, в свою очередь, создает дополнительный процесс.

### Разделяемая память

При инициализации процесса выделяется оперативная память. Процессы не имеют доступа к ресурсам других процессов без специальных механизмов обменна данных.

Смотри `2_not_shared_memory.py`

### CPU операции с применением multiprocessing

Убедимся, что в случае с несколькими процессами CPU-операции действительно будут отрабатывать быстрее.

Смотри `3_synchronous.py` и `4_math.py`

### Минусы многопроцессного программирования

1. Накладные расходы на инициализацию дочернего процесса. В зависимости от способа инициализации нужно выделить ресурсы в системе и скопировать все, что было в родительском процессе.

2. Раздельная память. Нет возможности напрямую обмениваться данными между процессами.

3. Ограничение системы на количество процессов и выделенное им процессорное время.

4. Накладные ресурсы на системные вызовы переключения процессов.

5. Информация, передаваемая непреднамеренно завершенным процессом, может быть повреждена. Например, если мы решили убить процесс, или он был завершен из-за возникшего исключения.

### Особенности работы при многопроцессном программировании

1. Избегайте перемещения больших объемов данных между процессами.

2. Не забывайте убивать "зомби" процессы.

3. Аргументы функций должны быть "pickled".

4. Если требуется передавать данные между процессами, программа должна быть спроектирована так:

    - родительский процесс передает данные в очередь, т.е. явлвяется единственным писателем информации.
    - дочерние процессы получают данные для обработки, т.е. являются читателями информации.

        Например, родительский процесс добавляет в очередь задачи и параметры, которые нунжо решить, а дочерние процессы по мере освобождения получают эту информацию и производят работу по ее обработке.

## Треды (thread) / Потоки

Это наименьшая единица обработки, исполнение которой может быть назначено ядром системы. Потоки в рамках одного и того же процесса могут совместно использовать ресурсы - такие, как память. А процессы явно не разделяют этих ресурсов.

Может показаться, что несколько работающих тредов внутри процесса будут выполняться параллельно, как и несколько запущенных процессов, но в Python это не работает. Из-за глобальной блокировки интерпретатора, только один поток может выполнять код Python одновременно.

![thread](/static/thread.png)

Если необходимо выполнить CPU bound операцию, реализация с помощью тредов будет плохим решением. В обоих случаях только 1 поток будет обрабатываться одновременно. В случае с несколькими тредами система будет тратить ресурсы на переключение тредов.

Смотри `5_threads.py`

### Общая память

У тредов общая память. Треды запущены внутри одного процесса разделяют его ресурсы. Для передачи данных между тредами лучше использовать библиотеку `queue`. Она обеспечит безопасный обмен данными между тредами. О методах синхронизации тредов, можно дополнительно узнать в библиотеке `threading`.

Смотри `6_shared_memory.py`

### CPU-операции с тредами

Это плохая идея. Нет смысла считать математику в тредах: появляются накладные расходы на их переключение. Это может иметь смысл только при работе с IO-операциями, хотя это тоже не лучшее решение.
Смотри `7_parallel.py`
