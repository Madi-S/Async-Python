# Conclusion

## Результаты производительности (IO & CPU Bound)

### Запросы на сервер (IO Bound)

-   Последовательные запросы (3 место)

-   Запросы в тредах (1 место)

-   Запросы в процессах (2 место)

При работе с операциями ввода вывода самым медленным подходом является синхронный ввиду того, что каждая следующая операция ждет завершения предыдущей.

В случае использования потоков ситуация сильно меняется и скорость выполнения возрастает пропорционально количеству задействованных потоков. Несмотря на то, что GIL не позволяет одновременно выполнять нессколько потоков сразу, потоки переключаются между собой, пока они находятся в ожидании, другой поток проивзодит операцию, что и приводит к уменьшению времени выполнения операций ввода вывода.

При работе с процессами результаты соизмеримы с проивзодительностью потоков, хотя немного уступают в скорости, это связано с тем, что на развертывание процесса требуется больше времени.

### Математические вычисления (CPU Bound)

-   Последовательные вычисления (2 место)

-   Вычисления в тредах (3 место)

-   Вычисления в процессах (1 место)

Классический синхронный подход при выполнении математических задач оказался сопастовим с потоками. Оба подхода обрабатываются одним ядром, но в случае с потоками - есть расходы временных ресурсов на переключение между ними. По этой причине математические вычисления выполнять в потоках бесмыссленно.

С процессами ситуация кардинально отличается, здесь скорость выполнения операций растет пропорционально количеству свободных ядер, готовых обрабатывать нашу программу.

## Django vs Aiohttp

### Производительность при увелечении количества параллельных запросов

При увелечении количества одновременных клиентов в aiohttp время на выполнение запроса незначительно увеличивается, при этом количество запросов, которые может выдержать сервер увеличивается.

У Django время на выполнение запроса значительно больше, чем у aiohttp, и способность принять запросы не меняется от нагрузки.

### Производительность при увелечении времени IO Bound операций

При увелечении времени выполнения данных операций в aiohttp, увеличивается время на выполнение запроса, уменьшается способность одновременно обслуживать несколько запросов, при этом показатели Django падают по сравнению с aiohttp в разы.

### Производительность при увелечении количества параллельных запросов, если в aiohttp использовать синхронную операцию

При выполнения в коде синхронных операций (`await asyncio.sleep() -> time.sleep()`) aiohttp по производительности приравнивается к Djanog
