# Django vs Aiohttp

## Django

Это синхронный фреймворк. Один запущенный процесс django будет обрабатывать одного клиента. Это неплохо, если мы выполняем CPU Bound операции. Мы занимаем вычислительную мощность процессора и под эту операцию выделяем отдельный процесс. Однако, это неэффективно, если выполнять блокирующие IO Bound операции. Процесс/поток будет заблокирован на все время ожидания операции.

Чтобы обслужить больше одного клиента одновременно, нужно запустить дополнительные процессы. Получается, что максимальное количество одновременно обслуживаемых клиентов будет равно количеству одновременно запущенных процессов. При этом процессы в большинстве случаев будут ожидать, когда выполнится IO-операция и ничего не делать, а процессор будет тратить ресурсы на переключение между "спящими" процессами.

Большинство монолитных приложений на Django работают только с БД. Зачастую база данных находится на том же сервере, и все запросы к ней выполняются быстро. Но если увеличивается время выполнения запросов к БД, или добавляется логика обращения к другим микросервисам, то производительность и эффективность утилизации ресурсов резко падает.

В ситуации, когда приложение в основном ожидает выполнения IO Bound операций (выполнения запросов в БД или другие микросервисы), подойдет асинхронное программирование и аинхронные фреймворки - например, aiohttp.

## Когда стоит использоват асинхронный подход?

### Микросервисная архитектура

Используется микросервисный подход. Для формирования ответа пользователю нужно выполнить много обращений к другим микросервисам.

### Задачи доставки информации в реальном времени (например, уведомления или чаты)

Для реализации таких задача используется технология web-socket. Клиент открывает соединение и ждет, когда сервер пришлет новое сообщение или уведомление. В случае с синхронным подходом каждому клиенту нужно выделять отдельный поток/процесс, даже если он не получает сообщений. При таком подходе один сервер может обрабатывать тысячи соединений, а при асинхронном подходе десятки или сотни тысяч.

### Стриминговая нагрузка (например, s3-хранилище)

Обычный синхронный подход для загрузки файлов - получить весь файл, затем отправить его дальше в s3-хранилище. Такой подход удовлетворительно работает, когда размеры файлов сравнительно небольшие: 10-100 Мб. Но если файл весит гигабайты, использовать веб-сервер как буфер будет плохой идеей. Решение проблемы загрузки больших файлов - сразу отправлять полученные данные дальше в пункт назначения, то есть "стримить". Aiohttp позволяет эффективно решать такую задачу и параллельно обрабатывать других клиентов.

## Результаты

Протестировать можно, запустив два сервера django & aiohttp в разных терминалах и с помощью какой-нибудь утилиты для масс отправления запросов на данные сервера. Очевидно, aiohttp справится лучше в IO Bound операциях, используя асинхронный подход.

Смотри `1_aiohttp.py` & `2_django.py`

## Важные примечания

На данный момент вышла 3-яя версия Django с поддержкой асинхронности. Но для полной совместимости еще много нужно сделать в самой Django и ее экосистеме.

Как видно из экспериментов, если в асинхронном фреймворке использовать синхронную операцию, производительность резко падает. Даже если в одном месте использовать быструю синхронную операцию, последствия на общую производительность все равно будут замечены.

### Что нужно сделать в Django для поддержания полной асинхронности?

-   Внутренние компоненты. Работа с ORM, cache и прочим остается пока синхронной. Эти компоненты пока не переписали, но сделали костыль `sync_to_async`. Скорее всего, в следующих версиях Django добавят нативную поддержку async await интерфейса без костылей.

-   Внутренние библиотеки `contrib`. Внутри Django есть набор готовых компонентов, которые позволяют быстрее писать код. Например, `django.contrib.auth`. Для поддерджки асинхроннго подхода нужно переписать все эти компоненты с использованием async await интерфейса.

-   Внешние библиотеки. Огромная база библиотек написанных сторонними разработчиками тоже должна поддержать асинхронность и переписать свои библиотеки под async await интерфейс. При этом нужно сохранить обратную совместимость, что является нетривиальной задачей.

Исходя из вышенаписанного, путь полной поддержки асинхронности в Django будет достаточно долгий, но с большой вероятностью в будущем мы придем к полному асинхронному подходу в Django.
