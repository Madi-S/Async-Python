# Asyncio Entities / Основные Сущности Asyncio

## Синтаксические конструкции asyncio

async - ключевое слово, через которое мы объявляем асинхронную функцию, короутину.

await - ключевое слово, через которое мы запускаем асинхронную функцию и передаем управление другим короутинам.

В обычных функциях асинхронные вызовы использовать нельзя, потому что это приведет к исключению `SyntaxError`, а вызывать синхронные функции с помощью await приведет к `ValueError`.

## Event Loop

Эта сущноть, управляющая задачами в асинхронной программе. Event Loop следит за асинхронными задачами и принимает решение, какой из них передать управление в определенный момент времени.

Смотри `1_event_loop.py` `2_event_loop_forever.py`

## Работа с короутинами и asyncio

### Task

Создается с помощью метода `.create_task()` типом `asyncio.Task`:

```python
loop = asyncio.get_event_loop()
loop.create_task(some_function())
loop.run_forever()
```

Внутри короутин мы можем использовать аналогичный метод, но `loop` уже не нужен. Библиотека asyncio все сделает за нас. В примере `3_tasks.py` мы запускаем аналогичного демона, но инициализируем воркеры не напрямую с использованием event.loop, а из другой короутины.

### Awaitable

Это все объекты, с которыми можно использовать ключевое слово await:

-   Coroutines
-   Tasks
-   Futures

Где `asyncio.Future` - это более низкоуровневое представление `asyncio.Task`. Смотри `4_coro.py`.

### Запуск нескольких короутин

Смотри `5_many_coroutines.py`

### Возвращение управления по timeout

При разработке нашего сервера мы делаем различные запросы по сети. Представим, что метод нашего API запрашивает какие-то опциональные данные, без котороых ответ все еще будт валидным. Защитим себя от проблем сторонних сервисов. Для этого воспользуемся функциями `wait_for` или `wait` и передадим значение таймаута. По истечению заданного интервала времени программа вернет управление, и мы сможем обработать запрос.

Смотри `6_timeout.py`

### Корректное завершение программы

Нам нужно перезапустить сервер. Он работает под нагрузкой, и в каждый момент времени происходят операции записи данных в базу. Мы не можем просто убить процесс, потому что в этом случае мы потеряем какие-то важные данные. Для этого нужно безопасно завершить программу, дождавшись всех походов в базу. Можно обработать исключение `CancelledError`. Отменяем все task'и и дожидаемся тех, что не завершились после отмены.

Смотри `7_safe_cancel_tasks.py` и `8_show_tasks_status_on_cancel.py`