# Sync to Async / Делаем Синхронный Код Асинхронным

## Введение

В прошлом, мы поняли, что плохо вызывать блокирующие и cpu bound операции в асинхронным коде. Но иногда вызвать синхронную операцию - или выполнять тяжелую cpu bound операцию - бывает необходимо.

### Практические Примеры

IO - операции

Нужно подключиться к системе, у которой нет асинхронной библиотеки. Сейчас это не так распространено. Но в таких ситуациях нужно писать ссвой коннектор и реализовывать протокол взаимодействия. Задача интересная, но достаточно нетривиальная и долгая, поэтому придумали альтернативный путь.

CPU - операции

Нужно пройтись по всем ключам большого json в несколько мегабайт, который получили от внешнего сервиса.

Смотри `1_run_in_executor.py`

В функцию `loop.run_in_executor` нужно передать `executor` (если передать None, то операции будут запускаться в потоках) и синхронную функцию, которую нужно исполнить.

Если в `loop.run_in_executor` передать асинхронную функцию `async def foo(): ... `, то `executor` ее вызовет без синтаксиса await. Будет создат объект короутины, но функция не выполнится.

Можно написать свой собственный executor. Он должен наследоваться от базового класса `concurrent.futures.Executor`.

## IO Bound Операции

Смотри `2_io.py`

Представим, что у нас есть блокирующая IO Bound операция `blocking_task`, для которой нет альтернативной асинхронной библиотеки.

Есть фоновая задача `ticker`, которая просыпается раз в секунду и печатает текущее время. Она нужна для понимания, заблокирован ли основной поток исполнения. Если в логах выполнения демона мы увидим разницу больше, чем в одну секунду - event loop заблокирован и не может своевременно передать управление нужной короутине.

Есть еще 2 воркера которые вполняют "полезную работу": `blocking_worker` и `async_thread_worker.blocking_worker` вызывает в цикле синхронную функцию. `async_thread_worker` запускает в `ThreadPool` выполнение синхронной функции и асинхронно ждет выполнения.

Однако, не злоупотребляйте этим методом. Используйте его только в тех случаях, когда не смогли найти асинхронную библиотеку к подключаемому сервису.
