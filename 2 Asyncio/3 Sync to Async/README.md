# Sync to Async / Делаем Синхронный Код Асинхронным

## Введение

В прошлом, мы поняли, что плохо вызывать блокирующие и cpu bound операции в асинхронным коде. Но иногда вызвать синхронную операцию - или выполнять тяжелую cpu bound операцию - бывает необходимо.

### Практические Примеры

IO - операции

Нужно подключиться к системе, у которой нет асинхронной библиотеки. Сейчас это не так распространено. Но в таких ситуациях нужно писать ссвой коннектор и реализовывать протокол взаимодействия. Задача интересная, но достаточно нетривиальная и долгая, поэтому придумали альтернативный путь.

CPU - операции

Нужно пройтись по всем ключам большого json в несколько мегабайт, который получили от внешнего сервиса.

Смотри `1_run_in_executor.py`

В функцию `loop.run_in_executor` нужно передать `executor` (если передать None, то операции будут запускаться в потоках) и синхронную функцию, которую нужно исполнить.

Если в `loop.run_in_executor` передать асинхронную функцию `async def foo(): ... `, то `executor` ее вызовет без синтаксиса await. Будет создат объект короутины, но функция не выполнится.

Можно написать свой собственный executor. Он должен наследоваться от базового класса `concurrent.futures.Executor`.

## IO Bound Операции

Смотри `2_io.py`

Представим, что у нас есть блокирующая IO Bound операция `blocking_task`, для которой нет альтернативной асинхронной библиотеки.

Есть фоновая задача `ticker`, которая просыпается раз в секунду и печатает текущее время. Она нужна для понимания, заблокирован ли основной поток исполнения. Если в логах выполнения демона мы увидим разницу больше, чем в одну секунду - event loop заблокирован и не может своевременно передать управление нужной короутине.

Есть еще 2 воркера которые вполняют "полезную работу": `blocking_worker` и `async_thread_worker.blocking_worker` вызывает в цикле синхронную функцию. `async_thread_worker` запускает в `ThreadPool` выполнение синхронной функции и асинхронно ждет выполнения.

Однако, не злоупотребляйте этим методом. Используйте его только в тех случаях, когда не смогли найти асинхронную библиотеку к подключаемому сервису.

## CPU Bound Операции

Смотри `3_cpu.py`

Код похож на предыдущий пример, но в `blocking_task` теперь CPU Bound операция: уменьшение счетчика. Если запустить `blocking_worker`, то как и в предыдущем примере, event loop заблокируется. В результате ticker выполнит только одну итерацию цикла, и мы увидим только одну строчку с датой.

Давайте оставим только `async_process_worker` и запустим `3_cpu.py`. Как и ожидалось, CPU Bound операция выполняется в отдельном процессе и не блокирует event loop. Так как запускается отдельный процесс, а межпоцессное взаимодействие работает через socket, при таком подходе мы как будто обращаемся к другому сервису по сети (IO Bound операция) и ждем выполнения запроса.

Теперь давайте оставим только `async_thread_worker`. На первый взгляд, ничего не поменялось. Все работает так же, как и с `async_process_worker`. Но нужно понимать, что так или иначе, но из-за GIL в один прекрасный момент времени будет исполняться только один поток. Поэтому CPU Bound операция будет отнимать процессорное время у event loop. При этом операционная система принимает решение в какой момент включить один или другой поток. Ткже добавляются накладные расходы на переключение между потоками.

Поэтому в случае с CPU Bound операциями. `ThreadPoolExecutor` лучше не применять. Есть механизм, который позволяет контролируемо передавать управление другой короутине из CPU Bound операции средствами asyncio.

## Обходной Путь для CPU Bound Операций

Смотри `4_cpu_workaround.py`

Чтобы работала кооперативная многозадачность, нужно, чтобы контекст переключался. Это происходит в момент выполнения вызова асинхронной функции с синтаксисом await.

В случае с бексонечным `while True` циклом управление никогда не вернется в event loop. Это потому, что никогда не будет вызвана асинхронная функция. Поэтому мы вызовем ее искусственно. Для этого вызовем `await asyncio.sleep(0)` специально со временем ожидания в 0. Вызывать ее можно управляемо раз в N итераций цикла.

В итоге получается:

-   CPU Bound операция будет тратить время процессора;
-   Но при этом будет периодически передавать управление другим короутинам для выполнения и вставать обратно в очередь event loop.

При таком подходе мы получим идентичный с `ThreadPoolExecutor` результат. Только в этом случае уже не операционная система решает, в какой момент отдать упрвление event loop, а мы сами.

При этом, если переключаться слишком часто, время исполнения CPU Bound операции будет слишком замедляться, а если переключаться слишком редко, то начнет страдать асинхронность.

```py
async def blocking_task():
    counter = 50_000_000
    while counter > 0:
        counter -= 1
        if counter % 1_000_000 == 0:
            await asyncio.sleep(0)
```

В случае выше, интервал превысит одну секунду. Как результат, `ticker()` не исполняется с интервалом в одну секунду.
