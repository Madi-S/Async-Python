# Base Server Components

## Введение

Веб сервисы, при всем их разнообразии, они чаще всего состоят из схожих частей, потому что они тоже служат одной цели - получить, обработать и отдать информацию.

В этом разделе вы выделим базовые общие части и объекты, которые скорее всего можно встретить в любом веб-сервере и рассмотрим их примеры в контексте aiohttp, а затем применим полученные знания и напишем свой aiohttp сервер.

## Сверху вниз

Начнем наше исследование сверху вниз - пройдем весь путь, который проходит пользовательский Request, чтобы, наконец стать прекрасным Response.

### Request

Объект Request включает в себя множество полезных данных, которые были собраны по пути от пользовательского браузера до бизнес-логики сервера. Например, путь запроса, заголовки, куки, тело, адрес источника запроса, добавленные атрибуты и т.д.

#### Пример - содержание типового Aiohttp Request

![aiohttp_request](/static/aiohttp_request.png)

Из объекта Request можно получить данные, переданные клиентом, и определить, что же он хотел сделать. Как понять, какую часть бизнес-логики приложения клиент хотел выполнить этим запросом.

Можно взглянуть на такие параметры, как path ('/files.upload') и method ('POST'). По этой паре чаще всего можно однозначно определить "намерения" запроса. Скорее всего, запрос передает какие-то данные для загрузки куда-то, и для этих действий на веб-сервере написана специальная функция. Но как найти эту связанную функцию? Это для нас может сделать Router

### Router

Это объект, который хранит в себе все связки "путь-логика" в приложении и умеет по пути и методу входящего запроса определить: какая часть функционала его "интересует". В aiohttp в роли `Router` выступает класс `UrlDispatcher`, который обладает двумя ключевыми методами, о предназначении которых можно догадаться по их немного упрощенным сигнатурам:

```python
def add_route(
    self,
    method: str,
    path: str,
    handler: Функциоанл
) -> Route
```

```python
async def resolve(self, request) -> Функционал
```

Говоря простыми словами, метод `add_route` добавляет какой-то функционал по ключу (method, path), а метод `resolve` достает эти параметры из Request и находит нужный функциоанл, если он был когда-то добавлен.

Если внимательно посмотреть на сигнатуру метода `add_route`, то можно увидеть, что он возвращает `Route`. Давайте рассмотрим его в деталях.

### Route

Это чуть более сложный объект, чем просто ключ (method, path). С помощью `Route` можно, например, задать такие параметры для совпадения пары "запрос-функционал":

-   Только строгое соответствие /user/get
-   `Route` с именованным параметром /user/{user_id}/get
-   `Route` с регулярным выражением внутри /user/{\d+}/get

Также можно обернуть `Route` в слой дополнительной логики. Например, сделать так, чтобы `Route` поддерживал CORS:

```python
app_.cors.add(app_.router.add_route('POST', 'files/upload', upload_function))
```

В коде выше видно, что на место `handler: Функционал` в сигнатуре метода `add_route` мы передаем какую-то `upload_function`. Это так называемый function-based view. Разберем что такое `View` вообще в следующем разделе

## View

Вызываемый объект, который на вход получает Request, а возвращает Response.

Между входом и выходом он выполняем какую-то бизнес-логику: валидирует данные, ходит в базу и в сторонние API, выкидывает ошибки, формирует ответ и многое другое. Любая функция или метод класса могут стать `View` - главное, чтобы они принимали на вход Request, а отдавали Response, о которым мы так же поговорим чуть позже. Но, конечно, есть общепринятые средства объявления `View`.

### Function-based View

Объявление `View` с помощью функции:

```python
async def hello(request):
    return web.Response(text='Hello World')
```

### Class-based View

Объявление `View` с помощью класса.

С помощью одного такого `View` можно покрыть все HTTP-методы, объявив их в разных методах класса с зарезервированными названиями (`get`, `post`, `update`, ...).

Также можно задать дополнительные хранимые данные. Например, создать поле `tags` и написать одинаковые тег `user` для всех `View`, связанных с пользователеми. А потом дописать логику так, чтобы `View` с одинаковыми тегами группировались в документации.

В общем, Class-based `View` позволяют сделать гораздо больше, чем Function-based `View`, поэтому мы будем на практике только их.

Однако не стоит забывать, что каким бы не был `View` (да хоть lambda-функцией), одна из его главных целей - вернуть Response.

#### Response

Объект, содержащие данные об ответе сервера на запрос клиента. В нем находятся статус ответа, данные, заголовки, новые куки и т.д. Например:

![aiohttp_response](/static/aiohttp_response.png.png)

Как только мы возовем метод `.prepare()` у такого Response, его статус и заголовки будут преобразованы в HTTP-вид и записаны в сокет: начнется его отправка обратно клиенту.

Пока не до конца понятно, как же связать все эти компоненты и объекты - не хватает какой-то общей точки, которая будет создавать Request, передавать его в Router и передавать Response обратно клиенту.

Этой точкой можно назвать App, который мы рассмотрим далее.

## App

Базовый класс aiohttp сервера. Можно сказать, что это его сердце, его диспетчер.

App слушает нужный порт, хранит в себе Router и умеет вызывать нужные его методы, генерирует объект Request из данных, пришедших на нужный порт, и многое другое.

Чтобы запустить веб-сервер, необходимо просто иснтанцировать App и вызывать на нем функцию `run_app`:

```python
from aiohttp import web

app = web.Application
web.run_app(app)
```

После запуска этого скрипта в консоли должна появиться следующая запись:

```bash
====== Running on http:/0.0.0.0:8080` ======
(Press CTRL+C to quit)
```

Это значит, что наш веб-севрер запущен и слушает порт 8080.

Теперь до запуска сервера можно дабавить какой-нибудь `Route` в `app.router`:

```python
app.router.add_post('/index', index_function_view)
```
