# Advanced Server Components

## Введение

Если бы возможности современных фреймворков ограничивались бы только базовыми компонентами, то было бы очень сложно и долго написать действительно рабочее и многофункциональное приложение.

В этом уроке мы коснемся вещей, которые значительно упрощают жизнь разработчикам в контексте aiohttp.

### Валидация

Это проверка правильности введенных данных. В более широком смысле валидация также может приводить данные к единому формату.

Пример. У пользователя просят ввести год рождения, а он вводит SDFSDF или 2050. Компонент валидации должен проверить эти данных и сообщить пользователю об ошибке. А если пользователю предложат ввести дату рождения в формате дд-мм-гггг, а сервер работает с форматом гггг-мм-дд? Валидация тоже может помочь, преобразовав данные с одного формата в другой и обратно. Также валидация может быть использована, чтобы скрыть часть данных.

## Swagger

Это инструмент для документирования API.

Позволяет описывать API в формате json и yaml. И по этим описаниям генерировать красивую страницу, на которой содержится описание всех методов, ответов на них и т.д. За отображение и работу этой страницы отвечает Swagger UI. Кроме отображения документации, он также позволяет эту документацию тестировать, отправляя запросы к API прямо из браузера. Помимо этого, по такой документации можно сгенирировать код веб-сервера для очень многих языков с помощью Swagger Codegen.

## Middleware

Это промежуточный слой бизнес-логики, который может выполняться и до и после того, как запрос дойдет до View.

С помощью middleware можно вынести общую логику, которая должна работать сразу в нескольких View. Самым частым примером является авторизационная middleware, которая проверяет предоставленные клиентом данные авторизации, и снабжает объект запроса авторизованным или анонимным пользователем.

Упрощенно это выглядит так: сначала запрос проходит все middleware по порядку их добавления, потом обрабатывается во View и возвращается обратно через все middleware в обратном порядке.

### Пример

Middleware для обработки ошибок после обработки запроса.

Сначала выполняются все стоящие middleware за этой, а потом View. Если возникла ошибка, она отлавливается на этом этапе и преобразуется в унифицированный вид:

```python
@web.middleware
async def error_middleware(request, handler):
    try:
        return await handler(request)
    except web.HTTPException as e:
        return json_response(status=e.status, text_status=e.text, data={})
    except Exception as e:
        return json_response(status=500, text_status=str(e), data={})
```

Middlewre всегда принимает на вход объект запроса и следующий за этой middleware обработчик запроса, то есть, следующую middleware или сам View.

Добавлять middleware в приложение можно двумя способами:

```python
from aiohttp import web

web.Application(middlewares=[error_middleware])
```

Или динамически:

```python
from aiohttp import web

app = web.Application()
app.middlewares.append(error_middleware)
```

## Mixin

Это некоторая дополнительная функциональность, которая обычно добавляется к классу, используя принцип композиции.

Миксины бывает удобно применять, когда несколько разных классов должны выполнять одну и ту же логику, и эта логика не должна выполняться для всех наследников класса. Это лишь один из случаев использования миксинов, но достаточно часто встречающийся.

Пример создания миксина:

```python
class AuthRequiredMixin:
    async def _iter(self) -> StreamResponse:
        if not getattr(self.request, 'user_id', None):
            raise HTTPUnauthorized
        return await super(AuthRequiredMixin, self)._iter()
```

А вот как его можно применить:

```python
class FilesListView(AuthRequiredMixin, web.View):
    ...
```

То есть класс наследуется сразу от двух родителей. Но, так как наследование происходит справа налево, то метод `_iter` класса переопределяет метод класса `web.View`.
