# Advanced Server Components

## Введение

Если бы возможности современных фреймворков ограничивались бы только базовыми компонентами, то было бы очень сложно и долго написать действительно рабочее и многофункциональное приложение.

В этом уроке мы коснемся вещей, которые значительно упрощают жизнь разработчикам в контексте aiohttp.

### Валидация

Это проверка правильности введенных данных. В более широком смысле валидация также может приводить данные к единому формату.

Пример. У пользователя просят ввести год рождения, а он вводит SDFSDF или 2050. Компонент валидации должен проверить эти данных и сообщить пользователю об ошибке. А если пользователю предложат ввести дату рождения в формате дд-мм-гггг, а сервер работает с форматом гггг-мм-дд? Валидация тоже может помочь, преобразовав данные с одного формата в другой и обратно. Также валидация может быть использована, чтобы скрыть часть данных.

## Swagger

Это инструмент для документирования API.

Позволяет описывать API в формате json и yaml. И по этим описаниям генерировать красивую страницу, на которой содержится описание всех методов, ответов на них и т.д. За отображение и работу этой страницы отвечает Swagger UI. Кроме отображения документации, он также позволяет эту документацию тестировать, отправляя запросы к API прямо из браузера. Помимо этого, по такой документации можно сгенирировать код веб-сервера для очень многих языков с помощью Swagger Codegen.

## Middleware

Это промежуточный слой бизнес-логики, который может выполняться и до и после того, как запрос дойдет до View.

С помощью middleware можно вынести общую логику, которая должна работать сразу в нескольких View. Самым частым примером является авторизационная middleware, которая проверяет предоставленные клиентом данные авторизации, и снабжает объект запроса авторизованным или анонимным пользователем.

Упрощенно это выглядит так: сначала запрос проходит все middleware по порядку их добавления, потом обрабатывается во View и возвращается обратно через все middleware в обратном порядке.

### Пример

Middleware для обработки ошибок после обработки запроса.

Сначала выполняются все стоящие middleware за этой, а потом View. Если возникла ошибка, она отлавливается на этом этапе и преобразуется в унифицированный вид:

```python
@web.middleware
async def error_middleware(request, handler):
    try:
        return await handler(request)
    except web.HTTPException as e:
        return json_response(status=e.status, text_status=e.text, data={})
    except Exception as e:
        return json_response(status=500, text_status=str(e), data={})
```

Middlewre всегда принимает на вход объект запроса и следующий за этой middleware обработчик запроса, то есть, следующую middleware или сам View.

Добавлять middleware в приложение можно двумя способами:

```python
from aiohttp import web

web.Application(middlewares=[error_middleware])
```

Или динамически:

```python
from aiohttp import web

app = web.Application()
app.middlewares.append(error_middleware)
```

## Mixin

Это некоторая дополнительная функциональность, которая обычно добавляется к классу, используя принцип композиции.

Миксины бывает удобно применять, когда несколько разных классов должны выполнять одну и ту же логику, и эта логика не должна выполняться для всех наследников класса. Это лишь один из случаев использования миксинов, но достаточно часто встречающийся.

Пример создания миксина:

```python
class AuthRequiredMixin:
    async def _iter(self) -> StreamResponse:
        if not getattr(self.request, 'user_id', None):
            raise HTTPUnauthorized
        return await super(AuthRequiredMixin, self)._iter()
```

А вот как его можно применить:

```python
class FilesListView(AuthRequiredMixin, web.View):
    ...
```

То есть класс наследуется сразу от двух родителей. Но, так как наследование происходит справа налево, то метод `_iter` класса переопределяет метод класса `web.View`.

## CORS

CORS (Cross-Origin Resource Sharing) - это механизм, основанный на передаче заголовков и предназначенный для запрета запроса данных с другого источника. Этот механизм обычно не используется при запросе статических файлов (css, js, картинки), он предназначен в основном для использования с ajax-запросами (например, POST-запрос с фронта на бэк). Использование этого мехназима удобнее, чем разрешать запрашивать данные только с того же ресурса, но безопаснее, чем разрешать запрашивать любые данные.

Что значит запрос с другого ресурса? Например, вы создали HTML-страницу и воспользовались для ее верстки стилями из библиотеки Bootstrap. У Bootstrap есть удобный CDN - вы можете просто указать ссылку на сервер Bootstrap'а и загрузить оттуда нужный CSS-файл со стилями. При рендеринге вашей страницы, браузер увидит ссылку на внешний ресурс и произведет запрос за нужными файлами. Это и есть Cross-Orign запрос: браузер запросил HTML-страницу с сайта iloveicecream.com, а потом эта страница запрашивает данные с сайта cdn.bootstrap.com Любой запрос, отличающийся от источника (в нашем случае источник это iloveicecream.com), хостом, портом или даже протоколом, является Cross-Orign запросом.

Что такого плохого может произойти без CORS? Например, вы зашли на сайт iamthief.com. На нем злоумышленник, с помощью XSS-атаки, или просто злобный админ разместили вредоносный скрипт. Он делает простую вещь: отправляет запрос на API банка, который переводит все деньги на счет другого человека (конечно, таких методов в открытом достпупе нет, но моделируем самый жуткий сценарий). Ваш браузер видит, что нужно выполнить код злоумышленника и посылает запрос на API. А вместе с запросом уходят куки, которые были поставлены банком, при вашем предыдущем запросе. И банк, отвечая на запрос, думает, что общается со своим любимым клиентом, а не с кодом злоумышленника и с удовольствием переводит ваши деньги на чужой счет. Конечно, этот пример немного утрирован - банки обычно не ставят куки, которые могут быть доступны на других сайтах (с помощью атрибутов domain и same-site).

Более реальный пример: на своем сайте злоумышленник держит код, который посылает запрос на сайт компании, где вы работаете, например, чтобы просто показать картинку, которая доступна только авторизованным пользователям. Если картинка показалась, то значит, что вы авторизованы на сайте компании, а значит вы работаете в этой компании. Теперь не так сложно просто позвноить вам, представиться службой безопасности вашей компании и узнать от вас логин/пароль, то есть использовать социальную инженерию.

Но порой CORS мешает жизни разработчиков, особенно если происходит локальная разработка на вашем компьютере. Вы запускаете фронтенд и бэкенд, но неожиданно фронтенд не может послать запрос на бэк из-за проблем с CORS. Это все потому что фронт запущен, например на 127.0.0.1:5000, а бэк на 127.0.0.1:8080, и браузер считает, что был произведен Cross-Origin запрос, порты ведь разные.

### Решение проблемы с CORS при локальной разработке

При разработке aiohttp сервера можно использовать библиотеку aiohttp-cors. Чтобы ее использовать надо при настройке `aiohttp.web.Application` также настроить `aiohttp_cors`:

```python
import aiohttp_cors
from aiohttp import web

async def handler(request):
    return web.Response(text='hello')

app = web.Application()
# Настраиваем aiohttp_cors и разрешаем запрашивать наши методы с любого источника
cors = aiohttp_cors.setup(app, defaults={
    '*': aiohttp_cors.ResourceOptions(
            allow_credentials=True,
            expose_headers='*',
            allow_headers='*',
        )
})
# добавляем наш Route в обработку CORS-запросов
cors.add(app.router.add_post('/method', handler))
```

Конфигурация `aiohttp_cors.setup` в примере разрешает любые запросы на ваш сервер с любого Origin. То есть при запросе с 127.0.0.1:5000 на 127.0.0.1:8080/method теперь не возникнет CORS-ошибки. Только надо не забывать добавлять нужные Route в объект `cors`.

Если вы разрабываете просто API-сервер и тестируете его с помощью Postman, то вам не нужно использовать aiohttp-cors.
