# Authorization and WebSockets

## Введение

Почти любое современное приложение получает данные из сторонних источников (базы данных, сторонние API, S3-хранлища и т.д.) и умеют в авторизацию/регистрацию. Разберем подробнее как добавить эти вещи к себе.

## Authorization

Это общее слово для процесса, состоящего из трех частей: идентификация -> аутентификация -> авторизация.

Идентификация проверяет, предоставлены ли данные и валидны ли они.
Аутентификация проверяет, правильны ли эти данные, например, есть ли такая пара логин/пароль в базе данных.
Авторизация проверят, если у пользователя с этими данными доступ к запрашиваему ресурсу.

### Cookie Auth

Чаще всего для авторизации пользователей используется метод, построенный на куки-файлах.

Разберем такой упрощенный алгоритм:

1. Пользователь отправляет пару логин/пароль на /user/login.
2. Сервер ищет совпадание в предоставленной паре в базе данных или конфигурационных файлах и находит ее.
3. Сервер собирает нужные данные о пользователе в объект и превращает его в json.
4. Сервер шифрует json-данные симметричным шифрованием.
5. Сервер добавляет заголовок Set-Cookie: <название куки>=<зашифрованные данные> и отправляет ответ.
6. Браузер пользователя сохраняет запись из заголовка Set-Cookie в своем хранилище.
7. Браузер пользователя отправляет заголовок Cookie с этими данными при каждом следующем обращении.
8. Сервер достает данные из заголовка Cookie и дешифрует их своим ключом.
9. При успешной расшифровке севрвер убеждается, что этот пользователь авторизован, ведь ключ для шифрования есть только у сервера.

Для работы по данному алгоритму в aiohttp существует библиотека для работы с сессиями aiohttp_session. Библиотека умеет хранить данные о сессии в разных типах хранилищ:

-   SimpleCookieStorage хранит информацию об авторизованном пользователе прямо в теле Cookie Value. Предназначено только для удобства тестирования и крайне небезопасно во всех остальных случаях.

-   EncryptedCookieStorage хранит информацию так же, как и SimpleCookie, но в зашифрованном виде. Используется симметричное шифрование 32-байтным ключом.

-   RedisStorage, MemcachedStorage, MongoStorage - хранят информацию в существующих хранилищах, а в Cookie Value хранит только уникальный ключ для ее получения. Требует настройку окружения.

## Внешние источники

Для работы с внешними источниками обычно выделяются три сущности.

### Accessor

Умеет образаться к сторонним источника данных и умеет преобразовывать полученные данные в нужный вид.

Например, можно сделать accessor для доступа к PostgreSQL или к внешнему API. Также, accessor обычно умеет выполнять подключение и отключение от внешнего источника данных.

Пример метода rfc-accessor'а, который ходит к внешнему API по RFC, получает данные и преобразует их к заданной схеме:

```python
async def get_date(self, proxy_number: str):
    result = await self.store.rfc.call(
        'Z_F_HR_LK2_GET_CALC_DATE', IV_PERNR=proxy_number
    )
    return GetDateInfo.Schema().load(result)
```

### Store

Набор всех accessor'ов из всех мест в приложении. Он инициализируется при старте приложения и по очереди подключает каждый accessor, тем самым обеспечивая их боеготовность:

```python
self.db = AioMongoAccessor(self, name='db')
self.qdb = TarantoolAccessor(self, name='qdb')
self.pgdb = PgAccessor(self, name='pgdb')
self.consul = ConsulAccessor(self, name='consul')
```

### Manager

Помогает вынести большие куски логики из View и переиспользовать их. Обычно manager включает в себя обращение сразу к нескольким accesor'ам. Например, при регистрации нового пользователя manager может сначала создать пользователя с помощью posgresql-accessor'а, а потом добавить ему сессию, воспользовавшись redis-accessor'ом.
