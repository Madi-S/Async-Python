# Event Loop

## Введение

### Генераторы

Event Loop в Python возможен благодаря генераторам. Давайте вспомним, что это такое. Основный признак генератора в Python - инструкция `yield`. Ее наличие показывает, что функция является генератором.

Пример генератора:

```python
def my_generator():
    print('i am generator and i am being executed')
    a = 1
    yield a
    a += 1
    yield a

g = my_generator()
print(g.gi_frame.f_lasti)
# >>> -1

g.send(None)
print(g.gi_frame.f_lasti)
# >>> 6
```

### Future

Это сущность, которая является обещанием чего-то в будущем. Например, мы хотим подключитсья к сокету: создадим `Future` сейчас и отдадим ее тоже сейчас. А значение в нее положим когда-то потом - когда подключение выполниться.

Суть `Future` в том, что мы разделяем факт происхождения события и момент использования этого факта.

Пример использования Future.

Смотри `1_future.py`

У нас есть функция `Fetcher._connect`, которая является генератором и пытается установить соединение с хостом. Мы создади объект `f = Future()` и скажем, что в нем появится значение в тот момент, когда мы осуществим успешное подключение.

Зарегистрируем на селекторе наш файловый дескриптор, передадим туда `on_connected` и в этом `on_connected` установим результат. Например, `f.set_result(None)`. Этот момент будет означать, что `Future` завершилась с каким-то результатом, в данном случае - None.

Давайте посмотрим, как устроена эта `Future`:

```python
class Future:
    def __init__(self, name: str):
        self.result = None
        self._callbacks = []
    
    def add_done_callback(self, fn):
        self._callbacks.append(fn)
    
    def set_result(self, result):
        self.result = result
        for fn in self._callbacks:
            fn(self)
```

В момент вызова `self.set_result` мы записываем результат нашей `Future` и вызываем все callback-функции, которые были зарегистрированы на эту `Future`. То есть, мы можем при создании `Future` сказать: когда завершиться - то есть, когда появится какой-то результат - выполни такие-то действия.

Эти действия можно добавлять с помощью `add_done_callback`. Мы регистрируем какой-то callback на `Future`, почти так же, как регистрировали callback на сокет. И в тот момент, когда `Future` завершится, мы просто последовательно вызовем эти callback-функции.

В `_connect` мы еще не вызвали никаких `add_done_callback`, просто создали `Future` и сделали ее `yield`.

Если мы сейчас начнем просто дергать `.send()` у генератора `fetcher()`, то в первый раз нам вернется `Future`, а во второй раз вернется сокет, который может быть еще не готов к записи. Нам нужно, чтобы второй раз `.send()` дергался при наступлении события `EVENT_WRITE` или в callback-функции `connected`, которая как раз и будет вызвана при наступлении `EVENT_WRITE`.

Но для такой логики нам не хватает некоторой управляющей конструкции. Кто-то должен следить, выполнилась ли `Future` и продолжать выполнение генератора `_connect`

### Task

Пример `Task`:

```python
from examples.coroutines.futre import Future

class Task:
    def __init__(self, coroutine):
        self.coroutine = coroutine
        f = Future()
        f.set_result(None)
        self.step(f)
    
    def step(self, future: Future):
        try:
            next_future = self.coroutines.send(future.result)
        except StopIteration:
            return
        next_future.add_done_callback(self.step)
```

Сущность `Task` - задача, которую нам небоходимо выполнить.

Фактически это и есть короутина, ведь короутина - это функция, которая чем-то управляется. Нам нужно двигать исполнение генератора до `yield` и после `yield`, то есть, кто-то должен итерировать по этой функции, чтобы она завершилась. И задача `Task` как раз в этом: завершить функцию-генератор, например, `_connect()`.

### Как использовать Task, Future и fetcher

Примерно так:

```python
Task(Fetcher._connect('abcd.com', 80))
```

Разберемся, что происходим в строчке выше:

1. Мы создали генератор `Fetcher._connect()` - но он не начал выполняться, ведь это генератор.
2. Мы создали экземпляр `Task` и передали в его `__init__` наш генератор.
3. `Task` создал начальную `Future`, которая сразу выполнилась. Это нужно, чтобы соответствовать интерфейсу метода `step`.
4. `Task` вызвал метод `step` с выполненной `Future`.
5. Метод `step` вызвал `send` у нашего генератора, т.е. продвинул его выполненияе до следующего `yield`. Это очень важный момент: сейчас генератор `Fetcher._connect()` начал неблокирующее соединение сокета и зарегистрировал callback на событие сокета на запись. А еще генератор вернул нам новую `Future`.
6. Новая `Future`, возвращенная генератором, присвоилась в `next_future`.
7. Мы повесили callback на эту новую `Future`, то есть, попросили ее: когда ты выполнишься, вызови функцию `step` и передай в нее себя.
8. Через некоторое время у нас установилось TCP-соединение. Преположим, что кто-то (Event Loop) ждал этого события и вызвал нашу callback-функцию `connected`.
9. Функция `connected` отписала `selector` от подписки на событие этого сокета.
10. Функция `connected` вызвала `f.set_result()` - сделала `Future` завершенной.
11. При вызове `f.set_result()` `Future` установила `self._is_done = True` и начала вызывать зарегистрированные callback-функции.
12. Еще один очень важный момент: `Future` выполнилась и вызвала функцию `step`, как мы ей показали в шаге 7.
13. Все начало выполняться с пункта №5. Но теперь `.send()` уже не вернет очередную `Future`, а кинет ошибку `StopIteration` - генератор `Fetcher._connect()` закончил свое выполнение.
14. Ура! Мы вышли из `Task`, и он выполнен до конца, причем асинхронно - мы не ждали в цикле и не блокировались, пока соединение будет установлено.

Как выглядет `Event Loop`, который "продвигает" выполнение короутин мы уже видели в предыдущих разделах, приведм здесь код для наглядности:

```python
import selectors

selector = selectors.DefaultSelector()

def loop():
    while True:
        events = selector.select()
        for event_key, event_mask in events:
            callback = event_key.data
            callback()

Task(Fetcher(selector)._connect('abcd.com', 80))
loop()
```

Заметьте, что теперь в `Fetcher` при инстанцировании передается `selector` - это сделано для того, чтобы `Fetcher` в `_connect` мог зарегистрировать сокет на ожидания события `EVENT_WRITE`.

Мы все это сделали, чтобы получить код, который выполняется асинхронно, но не превращается в CallbackHell.

Теперь мы можем выполнить какие-то действия после того, как действительно произошел `on_connected`. Не делать их в `def on_connected`, в каком-то смещенном контексте, который непонятно где находится в данный момент, а продолжить исполнение, выглядещее синхронно. Мы что-то сделали, сделали `_connect`, зарегистрировали, сделали `yield.`

Так мы создали ожидание какой-то `Future`, ожидание события в будущем. Оно произошло, и мы продолжили исполнение.

Мы отвязались от `on_connected` и всего, что происходит там. Просто установили результат, чтобы потом продолжить исполнение.

Вспомним: когда у нас не было `self.sock.setblocking(False)`, у нас был просто `connect`, и мы печатил `connected`.

По факту все так и осталось: у нас есть `connect`, и мы печатаем `connected` в одной процедуре. Мы не опустились внутрь какого-то callback, не сменили контекст исполнения, мы все так же находися в той же самой функции, и там же выполнили `print('conncted')`. Просто благодаря использованию асинхронного подхода у нас появляется возможность дождаться, пока эта `Future` не завершится. Мы дождались этого и продолжили исполнение.

Так устроен весь асинхронный мир: что-то происходит там, что-то тут, и все как-то между собой взаимосвязано. Все, что мы пытаемся сделать - систематизировать этот процесс, чтобы он шел в линейном порядке. Благодаря этому механизму мы локализировали в одном месте эти разные непонятные события, которые происходят в разные моменты времени.

У нас есть функция `on_connected` в `class Fetcher`о, которая выполнилась, когда ОС что-то сообщила. Дальше у нас просто синхронно выглядящий код. Мы последовательно выполняем операции и не задумываемся о том, как сложно это все устроено.

Теперь давайте систематизируем это все в одном месте в следующем разделе.
