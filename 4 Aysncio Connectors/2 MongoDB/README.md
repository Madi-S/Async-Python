# MongoDB Connector

## Введение

Это NoSQL база данны, не являющиеся табличной базой и хранит данные иначе, чем реляционные базы данных по типу PostgreSQL.

NoSQL базы данных бывают разные:

-   Документированные
-   Key-Value
-   Колоночная
-   Графовая

Создавались они для обработки больших объемов данных и более легко масштабирования под высокие нагрузки.

Документированные БД хранят данные в документах, подобных объектам JSON. Каждый документ содержит пары полей и значений. Значения могут быть различных типов, включая такие типы, как строки, числа, bool, массивы или объекты.

Базы данных "ключ-значение" - более простой тип БД, где каждый элемент содержит ключи и значения.

Колоночные БД похожи на реляционные, за тем исключением, что данные хранятся не по строкам, а в колонках. Такие базы применяются для построения для построения аналитики в реальном времени. На основе такое БД построена Яндекс.Метрика.

Графовые базы данных хранят данные в узлах и ребрах в виде графов Узлы обычно хранят информацию о людях, местах и вещах, а ребра хранят информацию о взаимосвязях между узлами.

Примеры:

-   Документированные: couchbase, mongodb
-   Key-Value: redis, memcached
-   Колоночная: clickhouse
-   Графовая: neo4j

### Отличие реляционное схемы хранения от NoSQL

Несмотря на то, что между системами управления реляционными базами данных (СУБД) и базами данных NoSQL существует множество различий, одним из ключевых различий является способ хранения данных в БД.

Чтобы разобраться в отличиях между реляционными БД и NoSQL-БД, рассмотрим пример хранения информации о пользователе и его увлечениях. Нам нужно сохранить имя, фамилию номер мобильного телефона, город и увлечения пользователя.

В реляционной БД мы создадим две таблицы - users и hobbies:

![relational_db_tables](/static/relational_db.png)

Чтобы получить информацию о пользователе и его хобби одним запросом, нужно соединить 2 таблицы и написать примерно такой запрос:

```sql
SELECT u.*, h.hobby FROM Users AS u LEFT JOIN Hobbies AS h ON (h.user_id = u.user_id) WHERE u.id = 1
```

В случае с такой документированной БД, как MongoDB, можно сложить данные в один документ. Тогда схема данных будет выглядить следующим образом:

```json
{
    "_id": "uuid",
    "first_name": "Post",
    "last_name": "Malone",
    "cell": "8341923438",
    "city": "Manchester",
    "hobbies": ["singing", "video games", "cooking"]
}
```

Вся информация хранится внутри одного "документа", а данные можно получить за один запрос без соединений таблиц.

### Преимущества No-SQL подхода

<b>Гибкие модели данныех.</b> Базы данных No-SQL обычно имеют гибкие схемы, то есть записи в одной таблице (в терминах реляционных БД) могут иметь разный формат. Гибкая схема позволяет легко вносить изменения в базу данных по мере изменения требований.

Но в таком подходе есть существенный минус: нет фиксированной структуры, ,нет схемы данных, а значит, нужно быть готовым к сюрпризам, например, отсутствию полей, недопустимым типам данных и т.д.

Между реляционными и No-SQL базами данных можно провести аналогию с ЯП с динамической и статической типизацией. К примеру, Python и Golang/C++. В Python переменной можно присвоить любой тип, и это дает свои преимущества: код писать быстрее, его проще тестировать и т.д. Но в это же время мы не всегда знаем, какой тип принимает или возвращает функция. Иногда сложно догадаться, какая вообще будет вызвана функция, так как она была добавлена "черноей магией" питона.

<b>Горизонтальное масштабирование.</b> Для больнинства БД SQL требует вертикальное масштабирование - переход на более крупный и более дорогой сервер, когда нагрузка превышает возможности текущего. И наоборот больниство баз данных NoSQL позволяют масштабироваться горизонтально: вы можете добавлять более дешевые стандартные серверы, когда нужно.

<b>Быстрые запросы.</b> Запросы в базах данных NoSQL могут быть быстрее, чем в базах данных SQL. Почему? Данные в SQL-БД обычно нормализованы, поэтому запросы для одного объекта или сущности требуют объединения данных из нескольких таблиц. По мере роста ваших таблиц соединения могут стать дорогостоящими. Однако данные в базах данных NoSQL обычно хранятся так, чтобы оптимизировать их для запросов. Эмпирическое правило при использовании MongoDB - данные, которые доступны вместе, должны храниться вместе. Запросы обычно не требуют объединений, поэтому могут выполняться быстрее.

В этой главе мы не будем рассматривать все возможности MongoDB, это тема для отедльного разговора.

## Connectors

Рассмотрим две библиотеки (коннекторы или драйверы, кто как называет) для MongoDB:

-   [Motor](https://motor.readthedocs.io/en/stable/index.html): официальная асинхронная библиотека

-   [Aiomongo](https://github.com/sakal/aiomongo): неофициальная библиотека, которая не поддерживается без звездочек на GitHub

Спрведливый вопрос: зачем тогда существует aiomongo?

Если посмотреть в исходники библиотеки motor, можно найти использование функции `run_in_executor`. Как вы помните, `run_in_executor` помогает запускать синхронные IO-Bound операции асинхронно. Авторы библиотеки motor решили не переписывать библиотеку специально под asyncio, а использовали такой подход. В библиотеке вызываются методы из синхронного коннектора для MongoDB - pymongo.

Библиотеку aiomonngo написали без использования функции `run_in_executor` и поддержали нативные механизмы asyncio. Она получилась быстрее, можно посмотреть benchmark'и. Но по разным причинам она не поддерживается и не развивается. На текущий момент не рекомендуется использовать её в продакшне.

## Motor

Рекомендации по работе с motor:

-   Motor, по сути - обертка над библиотекой pymongo. Поэтому, если с документации motor чего-то не хватает, можно всегда поискать это в документации pymongo

-   Сама полная документация к библиотеке - ее исходный код. Код библиотеки motor неочевидный. Чтобы убедиться в этом, достаточно посмотреть на реализацию `AsyncIOMotorClient`. Но, так как motor - обертка над pymongo, всегда можно посмотреть на код pymongo. Пример того же клиента - это `MongoClient` в pymongo.

-   Библиотека во многом повторяет язык запросов MongoDB. Если возникают вопросы, как сделать тот или иной запрос - можно обратиться к документации [MongoDB](https://www.mongodb.com/docs/manual/crud)

### Примеры запросов в MongoDB

Смотри `1_crud.py`

`get_client` создает client к MongoDB, с помощью которого нужно выполнять запросы к базе. В момент создания клиента подключения к базе не происходит. Принимает URL вида: "mongodb://<user>:<pass>@<host>:port/".

`get_db` и `get_user_collection`. В Mongo существует иерархия сущностей: есть база данных, внутри которой находятся коллекции (как таблицы в реляционной БД). В motor можно писать `client.unexisting_db.unexisting_coll` и ошибок не будет. Если коллекции не существует, вы узнаете об этом при запросе.

Когда вы получили коллекцию, можно выполнять к ней запросы Методы, доступные у коллекции, повторяют методы, доступные у коллекции внутри MongoDB.

В этом примере приведены методы (`insert_one`, `find_one`, `update_one`, `delete_one`), которые выполняют действие только над одним найденным объектом, даже если заданному условию удоволетворяет больше одной записи.

## Dataclass

В предыдущей главе мы работали с Mongo с помощью словарей.

В главе про aiohttp мы говорили, что лучше описывать типы данных в коде, чтобы понимать какая у них вообще структура и избегать случайных ошибок.

В Mongo это еще более актуально. В каждый момент времени нужно понимать, с какими объектами мы работаем, какие поля у них есть и что вообще эти объекты умеют делать. Поэтому очень важно описывать в коде структура документов, которые хранятся в коллекциях Mongo.

### Пример

Смотрим `2_schema.py`

Разберем алгоритм действий:

1. Marshmallow не умеет работать с объектом типа `bson.ObjectId`, поэтому ее нужно сначала научить этому. Для этого описываем новое поле `ObjectIdField`, которое наследуется от базового класса `fields.Field`, и реализуем два метода `_deserialize` и `_serialize`. Первый метод вызывается, когда данные нужно превратить из словаря в объект `dataclass`, а метод `_serialize` - когда из объекта `dataclass` нужно получить словарь.

2. Чтобы в описании `dataclass` использовать тип `bson.ObjectId`, нужно явно указать, какое поле может обрабатывать такой тип данных. Для этого мы добавляем в `TYPE_MAPPING`, описанные ранее класс `ObjectIdField: Schema.TYPE_MAPPING[bson.ObjectId] = ObjectIdField`.

3. Описываем класс `User` так же, как делали в главе aiohttp.

### Как пользоваться описанным dataclass

Смотри `3_usage.py`

Пример похож на предыдущий, за исключением нескольикх нюансов:

-   `inser_user` принимает объект пользователя. Из него нужно получить словарь. Для этого можно воспользоваться функцией `asdict`, которая встроена в библиотеку dataclasses, или использовать `dump` из библиотеки marsmallow.

-   В примере используется способ через `asdict`. Далее из полученного словаря нужно удалить `_id`, чтобы Mongo автоматически сгенерировала свой `_id` для документа.

-   `find_user_by_id`, функция `collection.find_one()` вернет словарь. Его нужно превратить в объект `User`, поэтому нужно вызвать `User.Schema().load(document)` 

## Many

В предыдущих примерах мы везде использовали постфикс `_one`. Это значит, что Mongo выполняла операцию только с одним документом, даже если условию удоволетворяет несколько документов.

Но в Mongo доступны методы для получения/обновления/удаления множественнхы документов.

Смотри `4_many.py`

Рассмотрим в деталях этот пример:

-   `insert_many` - в эту функцию можно передать массив словарей, и Mongo за один запрос вставит все элементы

-   `find_using_cursor` и `find_using_async_for`. В Mongo, как и во многих БД есть `cursor`. С его помощью можно получать не все записи, которые вернул запрос, а частями. Например, запрос вернул 1000 записей, а мы получили только 10 из них.

Доступны 2 синтаксиса курсора:

-   `cursor.to_list(length=N)`. Тогда, даже если в запросе миллиард записей, при вызове `to_list(length=5)` вернется только 5 записей. Мы сможем эффективно обработать их, и при этом не заблокировав event loop.

-   `async for document in cursor` - это асинхронный итератор. По сути `async for` является синтаксическом сахаром (оберткой) для `cursor.to_list`. Он так же будет получать данные частями и предотвращать получение большого числа строк без возврата управления event loop.
