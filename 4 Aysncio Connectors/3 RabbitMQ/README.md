# RabbitMQ Connector

## Введение

RabbitMQ - брокер сообщений.

Основная идея довольно проста: он принимает и пересылает сообщения. Вы можете думать об этом как о почтовом отделении: когда вы отправляете почту в почтовый ящик, вы почти уверены, что почтальон в конечном итоге доставит почту вашему получателю.

### Немного теории

Message broker (брокер сообщений) - архитектурный паттерн в распределнных системах; приложение, которое преобразует сообщение по одному протоколу от приложения-источника в сообщение протокола приложение-приемника, тем самым выступая между ними посредником.

Producer - приложение, отвечающее за отправку сообщений. Это связано с брокером сообщений. В шаблоне публикации/подписки они называются издателями. К этой теме мы вернемся чуть позже.

Consuemer - конечная точка, принимающее сообщения, ожидающие в брокере сообщений. В шаблоне публикации/подписки они называются подписчиками.

Queue/topic - физическое или логическое хранилище сообщений, где брокер хранит все сообщения, которые еще не принял Consumer.

Примеры других брокеров сообщений:

-   Amazon MQ
-   Apache Kafka
-   Tarantool

### Протокол взаимодействия AMQP

RabbitMQ работает по стандарту протокола AMQP (Advanced Message Queuing Protocl).

Это открытый стандарт прикладного уровня для программного обеспечения, ориентированного на сообщения.

## Отправление и получение

Смотри `1_example.py`

Рассмотрим этот пример поподробнее:

-   `receiver`

    -   Вызвать функцию `connect` для создания подключения к RabbitMQ.
    -   Получить `channel`. Channel - это логическое соединение. По сути `channel` - это то же самое, что и `connection`, только без реального протокла TCP-соединения. В рамках одного физического подключения может быть несколько логических.
    -   Объявить очередь с помощью функции `declare_queue`. Функцию `declare_queue` можно вызывать несколько раз, ошибок она не вызовет. Такое поведение называют идемпотентным.
    -   Начать слушать сообщения из очереди с помощью функции `queue.consume`

-   `queue.consume`

    -   Когда сообщение поступит в очередь, и до него дойдет очередь, то будет вызван callback `on_message`.
    -   Параметр `no_ack=True` означает, что обработку сообщений не нужно подтверждать. Об этом поговрим чуть попозже.
    -   Есть более привычный для asyncio синтаксис без callback, с использованием асинхронного итератора:

    ```python
    async with queue.iterator() as queue_iter:
        async for message in queue_iter:
            print(message.body)
    ```

-   `sender`
    -   Нужно вызвать функцию `connect` для создания подключения к RabbitMQ.
    -   Далее получить `channel`
    -   Проверить создана ли очередь с помощью функции `declare_queue`. Если мы отправляем сообщение в несуществующую очередью, RabbitMQ просто удалит это сообщение.
    -   Отправить сообщение с помощью функции `channel.default_exchange.publish`. В RabbitMQ сообщение не может быть отправлено напрямую в очередь, оно всегда должно проходить через `exchange`. Все, что нам нужно знать сейчас - как использовать обмен сообщений по умолчанию, идентифицируемый пустой строкой (`default_exchange`). Этот обмен особенный: он позволяет точно указать, в какую очередь должно идти сообщение. Имя очереди необходимо указать в параметре `routing_key`.

## Надженость

### Подтверждение сообщений (acknowledgment)

Выполнение задачи может занять некоторое время. Вы можете задаться вопросом, что произойдет, если одни из `consumer` начнет длинную загрузку и упадет или завершиться, выполнив ее лишь частично.

С таким кодом, как в прошлой главе, RabbitMQ немедленно удаляет сообщение из памяти, как только доставляет его клиенту. В этом случае, если воркер неожиданно завершится, мы потеряем сообщение, которое он обрабатывал. Но мы, разумеется, не хотим терять задачи. Если `consumer` умирает, мы хотим, чтобы задание был передан другому `consumer`'у.

Чтобы сообщение никогда не потерялось, RabbitMQ поддерживает подтверждение событий. Подтверждение (acknowledgment) отправляется обратно от потребителя, чтобы сообщить RabbitMQ, что конкретное сообщение было получено, обработано и только потом брокер сообщений может его удалить.

Если потребитель умирает (его канал закрыт, RabbitMQ-соединение закрыто или TCP-соединение потеряно) без отправки подтверждения, RabbitMQ поймет, что сообщение было не обработано полностью и повторно поставит его в очередь. Если в то же время есть другие `consmuer`'ы он быстро перенаправит его другому потребителю. Таким образом, вы можете быть уверены в том, что ни одно сообщение не потеряется, даже если `consumer`'ы иногда умирают.

Подтверждение сообщение включено по умолчанию, но в предыдущей главе мы явно отключили его с помощью флага `no_ack=True`.

### Пример как работает подтверждение

Смотри `2_ack_receiver.py` и `3_ack_sender.py`

Код от предыдущего примера отличается только `no_ack=False`. По умолчанию `no_ack` равен `False`, поэтому этот параметр можно просто опускать. Но тут оставлено для наглядности:

```python
await queue.consume(on_message, no_ack=False)
```

Для подтверждения сообщения нужно вызвать контекстный менеджер `process`:

```python
async def on_message(message: IncomingMessage):
    print('Before sleep!')
    async with message.process():
        await asyncio.sleep(5)
    print('After sleep')
```

Или вызвать `ack`:

```python
async def on_message(message: IncomingMessage):
    print('Before sleep!')
    await asyncio.sleep(5)
    message.ack()
    print('After sleep!')
```

Нужно также отметить, если произойдет исключение перед `message.ack()`, сообщение никогда не будет подтверждено и никогда не попадет другому `consumer`'у. Поэтому для этого следует использовать контекстный менеджер `message.process()`.

### Персистентность

По умолчанию RabbitMQ хранит сообщения в оперативной памяти. Поэтому если сервер RabbitMQ упадет, сообщения будут утеряны.

Во избежание потерь в RabbitMQ есть механзи хранения сообщений на диске. Но при этом RabbitMQ по умолчанию нетранзакционный, он не гарантирует сохранность всех сообщений при внезапном выключении сервера. Часть сообщений, которые уже хранились на диске, сохранятся, но часть недавно принятых сообщениймогут быть потеряны. Поэтому этот механизм плохо подходит для обеспечения надежности.

Есть несколько способов, чтобы никогда не терять сообщения:

-   Получать подтверждения в стороны получателя - publisher-confirms
-   Создавать отказоустойчивый кластер RabbitMQ
-   Использовать транзакции в RabbitMQ (не рекомендуется, так как снижает производительность)
-   Использовать другие транзакционные брокеры сообщений

## Правила доставки

### Емкость потребителя

В предыдущем разделе мы видели: когда `receiver` запустился, он сразу принял несколько сообщений из очереди. Сообщения выполнялись 5 секунд, но, несмотря на это, `receiver` все равно продолжал набирать задачи.

В этом примере это нестрашно. Но если бы задач были сотни тысяч, а `receiver` начал жадно их потреблять, он просто бы забился. При этом запуск новых `receiver`'ов не поможет, так как первый уже нахватал задач и другим просто нечего будет делать.

Так происходит потому, что RabbitMQ просто отправляет сообщение, когда оно попадает в очередь. Он не учитывает количество неподтвержденных сообщений для потребителя. Он просто слепо отправляет кадое n-ое сообщение потребителю.

Чтобы избежать этого мы можем использовать метод `set_qos` с параметром `prefetch_count = 1`. Это говорит RabbitMQ не отправлять новое сообщение потребителю, пока он не обработает и не подтвердит предыдущее. Вместо этого, сообщение уйдет следующему работнику, который еще не занят.

Смотри `4_qos.py`

С помощью:

```python
await channel.set_qos(prefetch_count=1)
```

Мы установили, что одновременно `receiver` может обрабатывать не больше одной задачи. Таким образом, можно управлять количеством параллельных короутин, которые будут запускаться в `receiver`.

После запуска мы должны увидеть следующее:

```
[*] Waiting for messages
Before sleep!
After sleep!
Before sleep!
After sleep!
Before sleep!
```

### Exchanges

В предыдущих примерах мы рассматривали очереди обработки данных. Каждая задача доставляется ровно одному потребителю. В примерах ниже мы изменим режим доставки и отправим сообщения нескольким потребителям. Этот паттерн проектирования называется pub/sub. Он позволяет очень гибко добавлять новые компоненты в систему.

Представьте картину: президент страны объявляет по телевизору о нерабочей неделе. Призидент - sender, телевизор - шина событий, жители страны - потребители, которые что-то делают с этой информацией. Кто-то из слушателей обрадуется, кто-то огорчится и куда-нибудь уедет, а кто-то начнет планировать финансы из-за "внезапного отпуска". Так и в системах, которые построены на основе паттерна pub/sub: кто-то объявляет новость, эта новость рассылается через брокер сообщений, потребители принимают это сообщение и выполняют какие-то действия на его основе.

Чтобы изменить способ доставки сообщений в RabbitMQ, нужно использовать `exchanges`. Основная идея модели обмена сообщений заключается в том, что `sender` никогда не отправляет сообщения напрямую в очередь. На самом деле, довольно часто производитель даже не знает, будет ли сообщение вообще доставлено в какую-либо очередь.

Вместо этого производитель может только отправлять сообщения в `exchange`. Exchange, с одной стороны, получает сообщения от производителей, а с другой, помещает их в очереди. Exchange должен точно знать, что делать с полученным запросом.

Должен ли он быть добавлен в определенную очередь? Следует ли добавлять его во многие очереди? Или его следует Выбросить? Правила для этого определяются типом обмена:

-   DIRECT - отправит сообщение в очередь на основе `routing_key`
-   FANOUT - отправит сообщение всем очередям, которые присоединены к `exchange`
-   TOPIC - отправит сообщение в очередь на основе `routing_key`, отличие в том, что в `routing_key` можно указывать шаблон, например, `logs`
-   HEADERS - роутинг будет происходить на основе заголовков, а не на основе `routing_key`

Чтобы объявить `exchange`, нужно вызвать:

```python
logs_exchange = await channel.declare_exchange("logs", exchange_type)
```

На самом деле в предыдущих примерах мы уже пользовались `exchange`, но это был основной `exchange` без имени (имя равно пустой строке) - `channel.default_exchange`.

Выше упоминалось, что с помощью `exchange` можно определить, в какую очередь положить сообщение. Для этого нужно соединить `exchange` с сообщением (bind). Более того, очередь может быть ассоциирована с несколькими очередями. При этом, если `exchange` не будет соедищнен с какой-либо очередью, RabbitMQ просто удалит помещенное в `exchange` сообщение.

Чтобы соединить очередь с `exchange`, нужно вызвать:

```python
await queue.bind(logs_exchange)
```

Смотри `5_exchange.py`

Что тут происходит?

-   Объявили `logs_exchange`, в параметрах указали имя и `ExchangeType.FANOUT`
-   Объявили очередь `queue = await channel.declare_queue('logger')`
-   Присоединили `logs_exchange`к очереди `queue.bind(logs_exchange)`

Пример создания временной очереди:

```python
# Постоянная очередь без имени
queue = await channel.declare_queue()

# Временная очередь без имени, существующая в рамках соединения
queue = await channel.declare_queue(exclusive=True)
```
