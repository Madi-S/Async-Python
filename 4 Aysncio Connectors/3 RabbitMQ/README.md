# RabbitMQ Connector

## Введение

RabbitMQ - брокер сообщений.

Основная идея довольно проста: он принимает и пересылает сообщения. Вы можете думать об этом как о почтовом отделении: когда вы отправляете почту в почтовый ящик, вы почти уверены, что почтальон в конечном итоге доставит почту вашему получателю.

### Немного теории

Message broker (брокер сообщений) - архитектурный паттерн в распределнных системах; приложение, которое преобразует сообщение по одному протоколу от приложения-источника в сообщение протокола приложение-приемника, тем самым выступая между ними посредником.

Producer - приложение, отвечающее за отправку сообщений. Это связано с брокером сообщений. В шаблоне публикации/подписки они называются издателями. К этой теме мы вернемся чуть позже.

Consuemer - конечная точка, принимающее сообщения, ожидающие в брокере сообщений. В шаблоне публикации/подписки они называются подписчиками.

Queue/topic - физическое или логическое хранилище сообщений, где брокер хранит все сообщения, которые еще не принял Consumer.

Примеры других брокеров сообщений:

-   Amazon MQ
-   Apache Kafka
-   Tarantool

### Протокол взаимодействия AMQP

RabbitMQ работает по стандарту протокола AMQP (Advanced Message Queuing Protocl).

Это открытый стандарт прикладного уровня для программного обеспечения, ориентированного на сообщения.

## Отправление и получение

Смотри `1_example.py`

Рассмотрим этот пример поподробнее:

-   `receiver`
    -   Вызвать функцию `connect` для создания подключения к RabbitMQ.
    -   Получить `channel`. Channel - это логическое соединение. По сути `channel` - это то же самое, что и `connection`, только без реального протокла TCP-соединения. В рамках одного физического подключения может быть несколько логических.
    -   Объявить очередь с помощью функции `declare_queue`. Функцию `declare_queue` можно вызывать несколько раз, ошибок она не вызовет. Такое поведение называют идемпотентным.
    -   Начать слушать сообщения из очереди с помощью функции `queue.consume`

-   `queue.consume`
    -   Когда сообщение поступит в очередь, и до него дойдет очередь, то будет вызван callback `on_message`.
    -   Параметр `no_ack=True` означает, что обработку сообщений не нужно подтверждать. Об этом поговрим чуть попозже.
    -   Есть более привычный для asyncio синтаксис без callback, с использованием асинхронного итератора:
    ```python
    async with queue.iterator() as queue_iter:
        async for message in queue_iter:
            print(message.body)
    ```

-   `sender`
    -   Нужно вызвать функцию `connect` для создания подключения к RabbitMQ.
    -   Далее получить `channel`
    -   Проверить создана ли очередь с помощью функции `declare_queue`. Если мы отправляем сообщение в несуществующую очередью, RabbitMQ просто удалит это сообщение.
    -   Отправить сообщение с помощью функции `channel.default_exchange.publish`. В RabbitMQ сообщение не может быть отправлено напрямую в очередь, оно всегда должно проходить через `exchange`. Все, что нам нужно знать сейчас - как использовать обмен сообщений по умолчанию, идентифицируемый пустой строкой (`default_exchange`). Этот обмен особенный: он позволяет точно указать, в какую очередь должно идти сообщение. Имя очереди необходимо указать в параметре `routing_key`.

## Надженость

### Подтверждение сообщений (acknowledgment)

Выполнение задачи может занять некоторое время. Вы можете задаться вопросом, что произойдет, если одни из `consumer` начнет длинную загрузку и упадет или завершиться, выполнив ее лишь частично.

С таким кодом, как в прошлой главе, RabbitMQ немедленно удаляет сообщение из памяти, как только доставляет его клиенту. В этом случае, если воркер неожиданно завершится, мы потеряем сообщение, которое он обрабатывал. Но мы, разумеется, не хотим терять задачи. Если `consumer` умирает, мы хотим, чтобы задание был передан другому `consumer`'у.

Чтобы сообщение никогда не потерялось, RabbitMQ поддерживает подтверждение событий. Подтверждение (acknowledgment) отправляется обратно от потребителя, чтобы сообщить RabbitMQ, что конкретное сообщение было получено, обработано и только потом брокер сообщений может его удалить.

Если потребитель умирает (его канал закрыт, RabbitMQ-соединение закрыто или TCP-соединение потеряно) без отправки подтверждения, RabbitMQ поймет, что сообщение было не обработано полностью и повторно поставит его в очередь. Если в то же время есть другие `consmuer`'ы он быстро перенаправит его другому потребителю. Таким образом, вы можете быть уверены в том, что ни одно сообщение не потеряется, даже если `consumer`'ы иногда умирают.

Подтверждение сообщение включено по умолчанию, но в предыдущей главе мы явно отключили его с помощью флага `no_ack=True`.

### Пример как работает подтверждение

Смотри `2_acknowledgment.py`