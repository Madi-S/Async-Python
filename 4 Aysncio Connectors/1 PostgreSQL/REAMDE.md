# PosgresSQL Connector

## Введение

Реляционная база данных - это набор данных с предопределенными связями между ними.

Эти данные организованы в виде набора таблиц из столбцов и строк. В таблицах хранится информация об объектах, представленных в базе данных. В каждом столбце таблицы хранится определенный тип данных, а в каждой ячейке - значение атрибуты. Каждая строка таблицы представляет собой набор связанных значений, относящихся к одному объекту или сущности. Каждая строка таблице может быть помечена уникальным идентификатором, называемым первичным ключом, а строки из нескольких таблиц могут быть связаны с помощью внешних ключей. К этим данным можно получить доступ многими способами, и при этом не требуется реорганизовывать таблицы БД.

Что будем рассматривать:

-   Асинхронные коннекторы к Postgres
-   Особенности взаимодействия с ними

Что не будем рассматривать:

-   Способы свзяи таблиц между собой: один к одному, один ко многим, многие ко многим
-   Нормальные формы: первая, вторая, третья и т.д.
-   Способы написания SQL-запросов

## Connectors

Сущетсвуют два асинхронных коннектора к Postgres:

-   [asyncpg](https://github.com/MagicStack/asyncpg)
-   [aiopg](https://github.com/aio-libs/aiopg)

И asyncpg, и aiopg используют "честные" механизмы asyncio. "Честные" означает, что библиотеки работают с базой данных Postgres с помощью неблокирующего сокета, а не просто вызывают функции инхронного коннектора psycopg2 с помощью `run_in_executor`.

Но asyncpg написан на CPython. Говоря простыми словами, это статистически типизорованный синтаксис Python, который можно преобразовать к коду на языке C. Поэтому он работает намного быстрее чем го аналоги

## Asyncpg

Смотри `1_asyncpg.py`

### Что делает этот код?

Для выполнения запросов нужно создать подключение к базе данных `connection`. Сделать это можно с помощью `get_connection` и `get_connection_by_dsn`. Есть 2 способ аполучить объект подключения:

-   Указать параметры host, port, user, password, database
-   Указать dsn: postgres://user:password@host:port/database, что по сути то же самое что и предыдущий способ, только запись более компактная

Подключение происходит в момент вызова `asyncpg.connect`. Поэтому, если параметры указаны неправильно, то будет вызвано исключение о том, что подключиться не удалось.

В функциях `insert`, `select`, `update`, `delete` используются методы подключения `fetchrow`, `fetch`, `execute`. Давайте рассмотрим их подробнее.

-   `fetchrow`: выполнит sql-запрос и вернет только одну запись - даже если запрос вернул больше. Если запрос вернул запись, метод возвращает объект `Record`, если нет - объект `None`.

-   `fetch`: выполнит sql-запрос и вернет все записи, которые вернул запрос, даже если там были миллионы записей. Если запрос не вернул никакой записи, метод возвращает список объектов `Record` или пустой список.

-   `execute`: выполнит sql-запрос и вернет строку, которую Postgres пишет после выполнения запроса. Например, "DELETE 1"

### Общие свойства функций `fetchrow`, `fetch`, `execute`

Функции могут принимать переменные. Перечисленные аргументы после запроса попадут вместо $1, $2 и так далее.

#### Важной примечание!

Никогда не форматируйте строки руками!
Всегда пользуйтесь форматированием библиотеки с помощью $1, $2 ...
Если форматировать строки ручками, то ваше приложение будет, мягко говоря, уязвивым - sql-инъекциям. Библиотека позволяет избежать этой уязвимости.

Библиотека конвертирует типы аргументов при запросе и строки при получении данных. То есть в функции insert, мы использовали `datetime.datetime.now()`, а библиотека привела дату к формату, который понимает Postgres. При получении данных через функцию `select` библиотека также автоматически приведет дату к объекту `datetime.datetime`.

## Transaction

Транзакция - группа последовательных операций с базой данных, которая представляет собой логическую единицу работы с данными. Транзакция может быть выполнена:

-   Целиком и успешно, соблюдая целостность данных ои независимо от параллельно идущих других транзакций

-   Не выполнена вообще, и тогда она не должна произвести никакого эффекта

Смотрим `2_transaction.py`

Разберемся, что тут происходит:

1. `insert_many` открывает транзакцию с помощью асинхронного контекстного менеджера `async with conn.transaction()` и выполняет 10 вставок в базу данных.

2. `transaction_with_error` также открывает транзакцию и вызывает `insert_many`, а затем специально вызывает исключение путем деления на ноль `1 / 0`. Посмотрите: транзакция открывается 2 раза, но на самом деле открывается 1 раз, в самый первый `async with`. Дальше все операции делаются в рамках самой верхней транзакции. При этом, когда произойдет исключение, все данные, которые записала функция `insert_many` откатятся назад

3. `select_many`: транзакции не всегда используются для вставок и обновлений данных. Они нужны также для получения результатов запроса частями. В функции открывается тразакция и создается `cursor`. По своему назначению это указатель на данные. Если мы вызовем `cursor.fetch(5)`, мы получим 5 записей из результата запроса и сдвинем указатель на 5 позиций. Метод `fetch` будет возвращать записи, пока данные не закончились в `cursor`. Иначе вернет пустой список.

## Concurrent

В предыдущих примерах мы получали подключения `connection` с помощью функции `get_connection_by_dsn`. Объект, который мы получали - `Connection` - "непотокобезопасный", т.е. его методы нельзя вызывать из разных короутин одновременно.

Смотри `3_concurrent.py`

Если запустить этот код, то возникнет исключение `InterfaceError`:

```
asyncpg.execptions._base.InterfaceError: cannot perform operation: another operation is in progress ...
Task was destroyed but it is pending
```

На каждую параллельную короутину нужно иметь собственное подключение. Есть два решения:

-   Создавать подключение на каждый запрос. Решение плохое, так как создание подключения ресурсоемкий процесс. К тому же Postgres создает дочерний процесс на каждое подключение. Как мы уже знаем, количество параллельных короутин может быть сильно больше количества запущенных процессов, поэтому это решение плохо подходит.

-   Создать несколько подключений к базе, по необходимости выдавать его короутинам, а после завершения работы возвращать обрабтно в общий чан. Объект, который содерджит в себе подключения, и из которого можно их брать, называется `pool`.

Смотри `4_pool.py`

`asyncpg.create_pool` создает pool

Функция `asyncpg.create_pool` принимает `min_size`, `max_size`. Это размеры `pool`, количество соединений, которые в нем находится. То есть количество параллельных запросов, которое можно выполнить к Postgres.

Асинхронный контекстный менеджер `pool.acquire()` достает из `pool` одно из свободных соединений. Если все подключения заняты, то короутина будет ждать, пока подключение не освободится. После выхода из контекстного менеджера, подключение `connection` будет возвращено обратно в `pool`.
