# Aiohttp Client

## Почему aiohttp?

1. Он быстрый
2. Для aiohttp пишут и адаптируют множество сторонних библиотек, например, aiohttp-session, aiohttp-api-spec, aiopg и множество других, что облегчает жизнь backend-разработчика
3. aiohttp обладает понятной и полной документацией. Очень редко приходится гуглить какие-то внутренние моменты работы этого фреймворка обычно все можно найти в официальной документации

## Aiohttp Client

Пример простого GET-запроса в `1_client.py`

### Разбор полетов

Первое, что здесь создается это `ClientSession`. Объект сессии можно сравнить с браузером, в нем хранятся общие параметры клиента: открытые соединения к серверу, cookies, общие заголовки, общие правила обработки timeout и так далее. Однако, необязательно создавать сессию на каждый запрос. По умолчанию сессия содержит несколько подключений к серверу (connection pool) и использует механизм `keep-alives` для того, чтобы не устанавливать каждый раз соединение с сервером, а переиспользовать уже установленные соединения. Переиспользование подключений может сильно ускорить ваше приложение.

Далее, выполняется GET-запрос - `async with session.get(...) as r`.

`session.get` - принимает параметры запроса: url, данные запроса, заголовки и cookies, специфичные для данного конкретного запроса.

`r (response)` - переменная, из которой можно получить ответ после выполнения HTTP запроса.

Стоит также отметить, что какие-то результаты доступны сразу, например, статус, заголовки, cookies. Однако, тело ответа нужно вычитывать отдельно. Чтение ответа является тоже асинхронной операцией: методы `read(), text(), json()` являются короутинами, и их следует вызывать с ключевым словом await.

В некоторых ситуациях, таких как чтение большого файла, нужно получить тело ответа частями.

`await r.read()` - возвращает данные в байтах

`await r.text()` - определяет кодировку и декодирует строку сразу

`await r.json()` - делает то же самое, что и `r.text()`, но еще и преобразовывает ответ в объект словаря

## Примеры запросов

Смотри `2_examples.py`

## Data Classes

Пример ситуации когда нужные датаклассы - у нас есть некоторая функция, которая обращается к ресурсу httpbin.org и возвращает тело ответа в словаре:

```python
import asyncio
import aiohttp

async def get_json():
    async with aiohttp.ClientSession() as session:
        async with session.get('http://httpbin.org/get') as r:
            return await r.json()

asyncio.run(get_json())
```

Без запуска кода или без документации портала httpbin нельзя определить что возвращает API. Для понимания кода было бы очень удобно знать структуру ответа API, а в идеале иметь Python объект, который ее описывает. Для таких целей в Python есть `dataclass`. Этот декоратор позволяет удобно описывать и структурировать данные без оперирования словарями.

Смотри `3_dataclass.py`

Код стал гораздо понятнее. Теперь без дополнительных источников или гадалок можно узнать какие данные возвращает API. Но при этом мы добавили себе дополнительную работу по описанию ответа в dataclass и по созданию объекта `GetResponse` из словаря data (mapping). А это достаточно рутинная работа.

От описания ответа никуда не денешься, но для процесса мапига и валидации есть библиотека `marshmallow`. А для нее есть отдельный модуль, который связывает `marshmallow` и `dataclass`, которая на удивление называется `marshmallow_dataclass`.

Смотри `4_marshmallow.py` и `5_marshmallow_dataclass.py`

Пояснения:

-   Нужно использовать `@dataclass` из библиотеки `marshmallow_dataclass`

-   В классе `Meta` описываются параметры для marhsmallow-схемы

-   Конструкция `field(metadata={'data_key': 'Accept-Encoding'})` используется тогда, когда название поля в исходных данных нельзя использовать как название переменнной в Python. Например, как в случае с `Accept-Encoding`

-   `Schema: ClassVar[Type[Schema]] = Schema` нужно добавлять, чтобы было удобно вызывать процесс конвертации данных: `GetResponse.Schema().load(data)`. В результате мы сразу получим объект `GetResponse`. Но можно обойтись без этого синтаксиса и создать схему руками.

Финальный код получился бы следующим образом:

Смотри `6_final_dataclass.py`
