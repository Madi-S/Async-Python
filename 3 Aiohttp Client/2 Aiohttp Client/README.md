# Aiohttp Client

## Почему aiohttp?

1. Он быстрый
2. Для aiohttp пишут и адаптируют множество сторонних библиотек, например, aiohttp-session, aiohttp-api-spec, aiopg и множество других, что облегчает жизнь backend-разработчика
3. aiohttp обладает понятной и полной документацией. Очень редко приходится гуглить какие-то внутренние моменты работы этого фреймворка обычно все можно найти в официальной документации

## Aiohttp Client

Пример простого GET-запроса в `1_client.py`

### Разбор полетов

Первое, что здесь создается это `ClientSession`. Объект сессии можно сравнить с браузером, в нем хранятся общие параметры клиента: открытые соединения к серверу, cookies, общие заголовки, общие правила обработки timeout и так далее. Однако, необязательно создавать сессию на каждый запрос. По умолчанию сессия содержит несколько подключений к серверу (connection pool) и использует механизм `keep-alives` для того, чтобы не устанавливать каждый раз соединение с сервером, а переиспользовать уже установленные соединения. Переиспользование подключений может сильно ускорить ваше приложение.

Далее, выполняется GET-запрос - `async with session.get(...) as r`.

`session.get` - принимает параметры запроса: url, данные запроса, заголовки и cookies, специфичные для данного конкретного запроса.

`r (response)` - переменная, из которой можно получить ответ после выполнения HTTP запроса.

Стоит также отметить, что какие-то результаты доступны сразу, например, статус, заголовки, cookies. Однако, тело ответа нужно вычитывать отдельно. Чтение ответа является тоже асинхронной операцией: методы `read(), text(), json()` являются короутинами, и их следует вызывать с ключевым словом await.

В некоторых ситуациях, таких как чтение большого файла, нужно получить тело ответа частями.

`await r.read()` - возвращает данные в байтах

`await r.text()` - определяет кодировку и декодирует строку сразу

`await r.json()` - делает то же самое, что и `r.text()`, но еще и преобразовывает ответ в объект словаря
