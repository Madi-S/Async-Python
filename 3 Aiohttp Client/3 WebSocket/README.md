# Протокол WebSocket

## Введение

Предположим, что нам необходимо разработать чат в браузере. Уже привычно, то сообщения приходят сразу, как собеседник его отправил, без обновления страницы. Но сделать такой механизм средствами http может стать проблемой. Дело в том, что протокол http спроектирован так, что инициировать запрос может только клиент. Сервер не может отправить данные клиенту в случайный момент времени, а только тогда, когда клиент обратился к нему.

Исходя из этих ограничений, можно придумать следующие решения:

### Polling

Клиент бесконечно спрашивает сервер, есть ли для него новые сообщения. Если да, то сервер пришлет их клиенту и отобразит в браузере. Минус такого подхода в том, что клиенты отправляют большое количество "пустых" запросов, что захломляет канал передачи данных и бесмыссленно загружают сервер.

### Long Polling

Клиент так же бесконечно спрашивает сервер, есть ли для него новые данные, но при этом, если сообщений нет, то сервер удерживает соединение до тех пор, пока они не появятся.

То есть клиент делал запрос, который висит до тех пор, пока не появится новая информация для клиента от сервера. Как только информация появится, сервер отправляет данные и закрывает соединение. Клиент получает ответ и отображает изменения. Такой подход решает проблему большого количества "пустых" запросов, но при этом остаются накладные расходы на инициализацию долгих запросов. К тому же раз в какой-то период соединение все равно обрабатывается и устанавливается новое. Так работает чат VK.

### WebSocket (ws)

Это протокол двухсторонней передачи данных. Это новй протокол, который является решение пролемам в вышеуказанных подходах.

Он обеспечивает полнодуплексные каналы связи через одно TCP-соединение. Протокол WebSocket подразумевает взаимодействие между веб-браузером (или другим клиентским приложением) и сервером с меньшими издержками, чем HTTP, облегчая передачу данных в реальном времени от и к серверву.

Это стало возможным благодаря тому, что сервер предоставляет стандартизированный способ отправки контента клиенту без предварительного запроса клиента. Также сервер позволяет передавать сообщения туда и обратно, сохраняя соединение открытым. Поэтому между клиентом и сервером может происходить постоянный двусторонний диалог.

Связь обычно осуществляется через TCP-порт с номером 443, или 80 - в случае незащищенных подключений. То есть протокол работает на тех же портах, что и HTTP, и его внедрение не требует дополнительной конфигурации серверов.

#### Задачи, в которых может быть полезен WS

-   Бразуерные игры
-   Чаты и уведомления на сайте в реальном времени
-   Биржевые сервисы для отображения изменения котировок

## Aiohttp Web Socket Client

Смотри `1_ws_client.py`

Как и в случае с обычным http-запросом, нужно создать объект ClientSession. Для ws справедливы http-параметры: заголовки, cookies, timeout подключения и т.д.

Работает так, потому что инициализация ws-соединений начинается с http-запроса вида:

```
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
```

На что серевр должен ответить:

```
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
```

Поэтому при подключении можно передавать дополнительные заголовки или cookies, например, для авторизации.

После создания сессия нужно подключиться к серверу по протоколу ws. Для этого нужно вызвать функцию `ws_connect`.

Полезные методы (короутины) объекта `ClientWebSocketResponse`:

-   `ping`/`pong`: служебные методы, которые поддерживают ws-соединение. Если по TCP-соединению ничего не передавать, оно может закрыться по таймауту, а в функции `ws_connect` есть включенный по умолчанию параметр `autoping`
-   `send_str`/`send_bytes`/`send_json`: функции, позволяющие отправлять данные в web socket на сервер
-   `receive`: короутина, позволяющая получать данные из web socket с сервера. Короутина неявно обрабатывает сообщение PING, PONG и CLOSE, при этом не возвращая их. Она обрабатывает "игру в пинг-понг" и выполняет закрытие, если пришло сообщение CLOSE. Короутина `receive_str` разрешает получать только сообщения типа TEXT, `receive_bytes` сообщения типа BINARY и `receive_json` - сообщения типа TEXT, преобразовывая их в словарь.

При этом `ClientWebSocketResponse` является асинхронным итератором. При использовании синтаксиса ниже происходит вызов функции `receive`:

```python
async for msg in ws:
        print('New Message: ', msg)
```

Переменная `msg` являетс объектом класса `WSMessage`. Сообщение состоит из 3 полей: `type`, `data` и `extra`. Библиотека aiohttp обрабатывает служебные сообщения сама, а пользователю достаточно получать сообщения с помощью высокоуровневого интерфейса `receive`
