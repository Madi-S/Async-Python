# HTTP

# Как работают поисковые запросы

Hyper Text Transfer Protocol, то есть протокол для передачи гипертекста. В самой часто используемой на сегодняшний день версии этого прокотола, информация представлена в текстовом виде, то есть ее можно прочитать не только роботам, но и обычному человеку. Наш запрос на любую страницу преобразовывается в следующий вид:

```
GET /serach?sourceid=chrome%ie=UTF-8 HTTP/1.1
HOST: www.google.com
User-Agent: Chrome/90.0.4430.85
Accept-Language: en-GB,en;q=0.9,ru-RU;q=0.8,ru;q=0.7,en-US;q=0.6,la;q=0.5
...
```

-   GET - это метод HTTP-запроса
-   Host - это домен, то есть куда мы должны отправить запрос
-   User-Agent - заголовок, с помощью которого мы говорим сайту, с какого бразуера и устройства отправили запрос. Чтобы, например, открыть мобильную версию сайта, если запрос был сделан с телефона
-   Accept-Language - заголовок, с помощью которого мы говорим, что хотим только русско- и англоязычные сайты в поисковой выдаче

HTTPS - буква S на конце показывает необходимоть протокола в шифровании между клиентом и сервисом. Для этого используется протокол TSL или устаревший SSl -> HTTPS = HTTP + SSL (TSL). TSL и SSL предпологают под собой ассимметричное шифрование, главная цель которого - не передавать ключ к расшифровке по сети.

На этапе установки защищенного соединения был настроен TCP-канал с помощьюю трехстороннего рукопожатия. Чтобы воспользоваться этим каналом для отправки HTTP-запроса, необходимо преобразовать запрос в TCP-пакет. Для этого HTTP-данные преобразуются в бинарный вид и кладутся в поля для данных TCP-пакета. В TCP-пакете уже указаны:

-   Его порядковый номер относительного созданного TCP-канала
-   Контрольная сумма
-   Порт, на котором должен прийти запрос
    Порт - это виртуальный шлюз, принимающей стороны и который обычно пишется в конце доменного имени. Благодаря портам один физический сервер может обрабатывать множество протоколов, приходящих по одному и тому же сетевому кабелю. Например, HTTP по порту 80, а HTTPS на 443.

Далее необходимо упаковать TCP-пакет в IP-пакет, добавив данные о своем IP-адресе и об IP-адресе получателя. Данные TCP-пакета также кладутся в место для данных в IP-пакете. После этого, IP-пакет инкапсулируется в Ethernet-кадр, в котором указан физический MAC-адрес утройства, которому адресована эта информация. После чего, Ethernet-пакет в виде световых сигналов или радиоволн побитово передается по сети и доходит до получателя с помощью сложной системы хабов, коммутаторов и маршрутизаторов. Получив запрос, любой интернет-сервис выполняет обратное преобразование набора световых пучков или электрических сигналов в HTTP-запрос, повторяя всю вышеуказанную последовательность только в обратном направлении, что называется деинкапсуляцией.

В итоге создается HTTP-ответ, который выглядит примерно таким образом:

```
HTTP/1.1 200 OK
Server: gws
Date: Sun, 4 Feb 2024 06:01.03 GMT
Accept-Ranges: bytes
Content-Type: text/html; charset=UTF-8
Content-Length: 12
<html>
...
```

На первой строке указана версия протокола, статус ответа и текстовое описание статуса (OK). Далее идет ряд заголовков, несущих информацию, например, о типе данных (Content-Type) и их длине (Content-Length).

Далее, браузер клиента обрабатывает HTTP-ответ и, используя свой графический движок, отрисовывает HTML-разметку. В итоге, мы видим конечную страницу в графическом представлении.

## POST или PUT?

Для совершения HTTP-запроса необходимо указать его метод. В вышеуказанной части мы использовали метод GET для поиска информации. Метод - одно из нескольких слов, которые используются для того, чтоб уточнить, что хочет сделать клиент:

1. GET - клиент хочет получить информацию. Например запросить профиль пользователя в соцсети.
2. POST - клиент хочет создать информацию. Например, создать запрос в друзья.
3. PUT - клиент хочет изменить информацию. Например, отредактировать номер телефона в личном профиле.
4. DELETE - клиент хочет удалить информацию. Например, альбом с фотографиями.
5. PATCH - клиент хочет изменить часть информации. Например, удалить одну фотографию из альбома.
6. HEAD - клиент хочет получить только заголовки. Например, чтобы проверить, изменилась ли информация с последнего посещения ресурса, не загружая заново данные.
7. OPTIONS - клиент хочет узнать сможет ли сервер обработать его запрос. Например, принимает ли сервер запросы методом POST.

Существуют также методы TRACE и CONNECT, но их используют очень редко

### Как использовать методы?

Например, наш веб-сервис работает на домене `some-business.com`:

Если мы пошлем по url-адресу `some-business.com/some-path`:

-   GET-запрос, то выведется список всех товаров с уникальными идентификаторами {id: 1}
-   POST-запрос с информацией о товаре (имя, цена, описание), то создастся новый элемент
-   GET-запрос с id, то можно получить информацию о конкретном товаре
-   PUT-запрос с id, то можно изменить информацию о конкретном товаре, например, изменить его цену
-   DELETE-запрос с id, то удалится данный элемент целиком

Как итог, существует несколько HTTP-методов, каждый из которых обладает своей общепринятой семантикой. Любой метод можно использовать для любой цели, но всем будет куда понятнее, если семантика метода будет соответствовать выполняемой цели.

## Чем 200 лучше 500?

В протоколе HTTP прописано, что на любой запрос сервер должен отвечать каким-либо числовым кодом. Коды ответа могут находится в диапазоне от 100 до 599 включительно:

-   От 100 до 199 идут информационные коды:
    -   101 (Switching Protocols) может использоваться для того, чтобы попросить клиента общаться через WebSocket, а не через обычный HTTP
-   От 200 до 299 идут коды, обозначающие успех какой-либо операции:
    -   201 (Created) значит, что объект был успешно создан
-   От 300 до 399 идут коды перенаправления:
    -   301 (Moved Permanently) значит, что адрес метода поменялся и вернется заголовок с новым адресом, бразуер сам выполнит переход на этот новый адрес
-   От 400 до 499 идут коды, обозначающие ошибки пользователей:
    -   400 (Bad Request) значит, что пользователь послал неверный запрос, например, неправильно указал названия полей в JSON
-   От 500 до 599 идут коды, обозначающие ошибки сервера:
    -   500 (Internal Server Error) значит, что во время обработки клиентского запроса произошло исключение на сервере

## Зачем нужны заголовки?

Они представлюят собой строковую пару ключ-значение и являются частью HTTP-протокола. Заголовки (headers) можно передавать с любым запросом, и чаще всего они несут некоторую общую информацию, нужную для нескольких запросов. Чаще всего заголовки используются для передачи информации о клиенте (браузер, система и т.д.), об авторизации клиента и об особенностях передаваемого контента (тип, размер и т.д.).

Примеры самых часто встречающихся заголовков:

-   `Conent-Type: application/json` - данные будут передаваться в формате JSON
-   `Conent-Length: 104` - размер передаваемых данных составляет 104 байта
-   `Authorization: 0RI8JfdsB03QfJ2YjB2O4==` - клиент хочет авторизоваться через Basic Auth
-   `User-Agent: Safari` - запрос был выполнел из браузера Safari

Кроме общепринятых заголовков можно передавать любые свои кастомные заголовки. Важно помнить, что заголовки предназначены для передачи информации, которая используется в нескольких запросах. Не нужно делать так, посылая сообщения в чат: `X-My-Header: Hi! How are you?`. Для этого примера лучше подойдет передача данных в теле (body) запроса в формате JSON.

## Ты кто?

### Авторизация в веб-приложениях

Почти во всех приложениях нужна авторизация, чтобы определить кто шлет запросы и что ему нужно. Существуют три понятия:

1. Идентификация - проверка, что пользователь как-то представился и существует
2. Аутентификация - проверка на верность данных, введенным пользователем, для входа: логин, пароль
3. Авторизация - проверка, что пользователь имеет право использовать данный функционал

Классический сценарий, пользователь заходит на сайт и отправляет свои почту и пароль на сервер. Сервер же в свою очередь:

1. Находит в базе данных аккаунт клиента по введенной почте (Идентификация)
2. Сверяет пароли в базе данных и отправленный клиентом (Аутентификация)
3. Проверяет забанен ли пользователь или нет (Авторизация)

Обычно весь этот вышеуказанный процесс и называется авторизацией

### Cookies

Самым часто используемым способом авторизации являются Cookies (куки), так как их поддержка встроена во все браузера. Способ работает следующим образом:

1. Клиент отправляет запрос с данными, необходимыми для аутентификации, например, логин и пароль.
2. Сервер сверяет отправленные данные, и, если они верны, добавляет к ответу заголовок Set-Cookie с каким-то значением.
3. Браузер видит этот заголовок и сохраняет его значение к себе в локальное хранилище.
4. С каждым последующим запросом браузер будет отправлять заголовок Cookie с сохраненным ранее значением.
5. Сервер видит этот заголовок и авторизует пользователя в сервисе - при условии, что значение заголовка Cookie соответствует тому, что сервер записал в свою базу при авторизации.

Cookie является сетевым стандартом и обладают жестко заданным набором дополнительных полей, которые передаются вместе со значением Cookie в заголовке. Браузер сам умеет доставать эти данные из строки. Например, рассмотрим такую Cookie:

`Cookies: sessionid=841J; Domain=.some.web.site; Expires=Sun, 4 Jan 2024 10:20:30 GMT; Secure; HttpOnly; Max-Age=31536000; Path=/; SameSite=Lax;`

-   Cookie - ключ заголовка
-   sessionid - название куки
-   Expires - дата протухания куки
-   HttpOnly - флаг, который означает, что браузер не должен давать доступ к этой куки из JavaScript кода. Такой атрибут обычно ставят на куки, которые содержат важную информацию (например, сессию). Если страница содержит xxs-уязвимость, то злоумышленник не сможет получить данные этой куки
-   Max-Age - время жизни
-   Domain - на каких доменах можно использовать эту куки. Если перед доменом стоит точка, то куки действует на всех поддоменах этого сайта. Например, .some.web.site будет действовать и на commerce.some.web.site
-   Path - на каких относительных url-адресах сайта действует эта куки. Если значение равно "/", то куки отправляется на любые запросы к этому сайту. Например, если поставить path=/user, то при запросе commerce.some.web.site/user/profile заголовок куки будет отправлен, а на commerce.some.web.site/home - не будет этого куки
-   Same-Site - говорит бразуеру, можно ли использовать эту куки на других сайтах. У SameSite есть три режима:
    -   None - куки можно использовать на любом сайте
    -   Lax - куки можно передавать только для высокоуровневой навигации. Например, со ссылки на сайте, на котором эта куки была установлена
    -   Strict - куки можно использовать только на сайте, который ее установил

Одной из главной особенностей куки вляется ее время жизни. Это время устанавливается в заголовке Set-Cookie, а браузер следит за временем и удаляет куки из своего хранилища, если время жизни истекло. Установить это время можно с помощью атрибута Expires и Max-Age. Expires задает дату, а Max-Age задает кол-во секунд, то есть одинаковая информация, просто представленная в разных форматах. Единственная разница в том, что Expires поддерживается в Internet Explorer, а Max-Age - нет.

### Заголовок Authorization

Иногда использовать cookie неудобно и не нужно. Например, мы хотим запустить небольшое приложение и не хотим подключать базу данных, чтобы хранить информацию о сессих и пользователях, следить за временем жизни cookie и создавать метод авторизации для получения cookie клиентом.

В таких случаях, можно просто договориться о каком-то секретном ключе с пользователями сервиса, который они будут слать с каждым запросом, в заголовке. Или другой пример, мы хотим посылать какой-то токен, в котором содержится много полезной информации (например, JWT) и не хотим, чтобы он протухал. ДЛя таких случаев и был разработан заголовок Authorization.

Самым простым способом для такой авторизации является Basic Auth. Сначала клиент получает логин и пароль, например, user228 / nicePassword. Эти данные сохраняются на сервере в коде программы или в конфигурационных файлах. Клиент объединяет логин и пароль в такую строку: "user228:nicePassowrd", а затем кодирует ее в base64. Получившиеся строка (dXNlcjIyODpuaWNlUGFzc293cmQ=) отправляется вместе с заголовком Authorization и префиксом Basic: `Authorization: Basic dXNlcjIyODpuaWNlUGFzc293cmQ=`.

Сервер выполняет обратные операции и сравнивает логин и пароль с теми, что имеются у него. У этого способа авторизации есть большой минус: если кто-то украдет логин и пароль, он сможет нелегально пользоваться сервером до тех пор, пока эти данные не будут изменены. Поэтому данный способ стоит использовать только в комбинации с TLS-шифрованием или в закрытых сетях.

Существуют и другие способы авторизации в веб-приложениях, но в основном все они используют передачу каких-то данных через заголовки.

## Как отправить данные?

Данные в HTTP-запросе передаются в текстовом виде, если рассматривать HTTP/1.1. В HTTP/2 все передается в бинарном виде. Однако, это не означает, что мы можем передавать только строки. Чтобы передавать более сложные структуры данных, надо просто выбрать подходящий формат для передачи данныех.

### Form-Data

Это формат передачи данных в виде ключ-значение:

```
POST / HTTP/2.0
Host: some.web.site
Content-Type: application/x-ww-form-urlencoded
Content-Length: 13
say=Hi%to=Someone
```

Почти все данные в формах на сайте можно представить в виде пары ключ значения. Поэтому этот формат уже встроен в браузеры и в стандарт HTML. С помощью form-data можно также отправлять файлы. При отправке файлов, в HTTP-запрос включается так называемый boundary, в котором находится содержимое файлов, приведенное к унифицированному формату. В профессиональной разработке стоит использовать form-data только для передачи файлов. С остальными данными гораздо лучше справляются более комплексные форматы передачи.

### XML

Не очень хочется писать об этом формате, но надо...

XML - это формат для структурированного представления информации с помощью тегов, таких же по устройству, как HTML-теги. Вот пример XML-документа:

```xml
<article>
		<title>В Кокшетау построят АЭС</title>
		<comments>
				<comment>Это не правда</comment>
				<comment>Наконец-то!</comment>
				<comment>Разве это не опасно для жителей города?</comment>
				<comment>Опять деньги воруют</comment>
		</comments>
</article>
```

В наше время XML в сфере веб-программирования можно встретить чаще всего в legacy-продуктах. Во всех остальных приложениях чаще всего используется JSON. Ведь минусами XML являются

-   Избыточность: тот же самый контент можно переписать в JSON, используя куда меньше символов.

-   Необходимость согласования и документирования: чтобы разработать API, который отдает XML, надо написать документацию с указаниями: какие существуют возможные теги, какие атрибуты могут использоваться для этих тегов, как можно эти теги вкладывать друг в друга и т.д.

-   Сложность парсинга: как понять что comments - это массив? Надо найти закрывающий тег и посмотреть, что между тегами есть ряд одинаковых ключей.

-   Отчужденность от языков программирования: например, массив выглядит в:
    -   Python: ["1", "2"]
    -   JavaScript: ["1", "2"]
    -   JSON: ["1", "2"]
    -   XML: <array><value>1</value><value>2</value></array>

### JSON

JavaScript Object Notation. Самый любимый язык разметки веб-разработчиков. Он прекрасно интегрируется с существующими типами в ЯП, а для его парсинга есть готовые функции, встроенные в ЯП. Он в меру избыточен и эта избыточность ялвяется его плюсом: он человекопочитаемый и очень гибкий.

### Бинарные форматы передачи

Это форматы, которые оптимизированы под быстродействие. Например, формат ProtoBuf передет данные в бинарном виде, на каждое значение, в котором выделено жестко заданное количество бит. Также этот формат не передает ключи. Например, надо передать возраст пользователя и флаг, обозначающий, авторизован он или нет: "12true" -> {unit32}{bool} -> {32 бит}{1 бит}{15 пустых бит для 16-битного выравнивания} -> 48 бит -> 6 байт, когда в JSON: {"age": 12, "authorized": true} -> 28 символов -> 56 байт в кодировке UTF-8. Да, разница в размерах информации впечатляет!

Однако, минусы бинарного формата передачи данных перевешивают его быстродействие. Во-первых, они не читаемы от слова совсем. Во-вторых, бинарные форматы должнф быть жестко заданы как на клиенте, так и на сервере. Если клиент отправляет набор битов, то сервер должен уметь декодировать их по какой-нибудь схеме. Хорошее применение бинарных форматов - взаимодействие между микросервисами. В этом случае действительно важна скорость, а схема данных может быть обозначена в одном месте кода и синхронна обновляться как для отправляющего, так и для получающего.
