# Работа с Файлами

## Введение

Эффективная работа с файлами - не самая тривиальная задача, которая может показаться на первый взгляд. С маленькими файлами все может работать просто. Они целиком помещаются в памяти программы, ими легко оперировать, что позволяет их быстро передавать клиенту. Проблемы же начинаются при работе с объемными файлами. Такие файлы уже нельзя так просто хранить целиком в памяти веб-сервера при обработке. С ними нужно работать по частями.

### Streaming

Это подход, позволяющий эффективно работать с файлами. Основная идея в том, что большинство операций с большими файлами веб-сервер являются proxy между клиентом и файловом хранилищем. Поэтому нам нет необходимости хранить весь файл целиком. Достаточно оперировать в один момент времени небольшими частями этого файла. Эти части называются чанками (chunks).

Примеры, когда streaming подходит, а когда нет:

-   Вы создаете платформу, на которой есть достаточно длинные видеозаписи. В качестве хранилища записей используется Vimeo или S3-хранилище. В этом случае подход с чанками оправдан, потому что видео может быть тяжелым в плане памяти. Мы не обрабатываем его на лету, а просто проксируем видео в хранилище.
-   Вы делаете социальную сеть, и нужно сделать загрузку аватарок пользователей. В этом случае картинки относительно маленькие. К тому же велика вероятность, что картинку нужно будет как-то обработать, а для этого нужен весь файл. Поэтому подход с чанками использовать не стоит.

### Streaming

Смотри `1_streaming.py`

Библиотека aiohttp предоставляет удобный интерфейс для отправки данных по чанкам. Функция `session.post` умеет принимать в качестве аргумента:

-   Итераторы
-   Асинхронные итераторы

Давайте рассмотрим второй пример детальнее `second_approach`:

1. Библиотека aiofiles позволяет асинхронно, частями читать данные с диска:

```python
chunk = await f.read(64 * 1024)
```

2. Читаем пока `f.read` возвращает данные
3. Прочтенный чанк передаем в `yield`, а в этот момент управление вернется обратно в функцию `session.post`
4. Внутри короутина `session.post` получает `chunk`, который был передан через `yield`, и сразу же отправляет эту часть файла на сервер, при этом не храня часть файла в памяти
5. Так происходит до тех пор, пока не будет прочитан и передан весь файл - до последнего чанка

В резльтате нужная для отправки файла память равна размеру чанка, что сущственно меньше размера файла, или, когда мы бы читали его сразу целиком.
